<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0-rc1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sealin.net","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="不妄取, 不妄予, 不妄想, 不妄求;与人方便, 随遇而安。">
<meta property="og:type" content="website">
<meta property="og:title" content="Sealin">
<meta property="og:url" content="http://www.sealin.net/page/3/index.html">
<meta property="og:site_name" content="Sealin">
<meta property="og:description" content="不妄取, 不妄予, 不妄想, 不妄求;与人方便, 随遇而安。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sealin">
<meta property="article:tag" content="技术, 生活, 随笔">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.sealin.net/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sealin - 初闻不解词间意，再听已是曲中人。</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Sealin" type="application/atom+xml">
<link rel="stylesheet" href="/assets/css/APlayer.min.css" class="aplayer-style-marker">
<script src="/assets/js/APlayer.min.js" class="aplayer-script-marker"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sealin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">初闻不解词间意，再听已是曲中人。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-35/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-35/" class="post-title-link" itemprop="url">35 | Truffle：语言实现框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 18:05:15" itemprop="dateCreated datePublished" datetime="2020-01-23T18:05:15+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-rwZokYzN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-rwZokYzN"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频35",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/2b/05/2bf0b4760e1aac3dc495918fe4dd0a05.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们来聊聊 GraalVM 中的语言实现框架 Truffle。</p>
<p>我们知道，实现一门新编程语言的传统做法是实现一个编译器，也就是把用该语言编写的程序转换成可直接在硬件上运行的机器码。</p>
<p>通常来说，编译器分为前端和后端：前端负责词法分析、语法分析、类型检查和中间代码生成，后端负责编译优化和目标代码生成。</p>
<p>不过，许多编译器教程只涉及了前端中的词法分析和语法分析，并没有真正生成可以运行的目标代码，更谈不上编译优化，因此在生产环境中并不实用。</p>
<p>另一种比较取巧的做法则是将新语言编译成某种已知语言，或者已知的中间形式，例如将 Scala、Kotlin 编译成 Java 字节码。</p>
<p>这样做的好处是可以直接享用 Java 虚拟机自带的各项优化，包括即时编译、自动内存管理等等。因此，这种做法对所生成的 Java 字节码的优化程度要求不高。</p>
<p>不过，不管是附带编译优化的编译器，还是生成中间形式并依赖于其他运行时的即时编译优化的编译器，它们所针对的都是<a href="https://en.wikipedia.org/wiki/Compiled_language">编译型语言</a>，在运行之前都需要这一额外的编译步骤。</p>
<p>与编译型语言相对应的则是<a href="https://en.wikipedia.org/wiki/Interpreted_language">解释型语言</a>，例如 JavaScript、Ruby、Python 等。对于这些语言来说，它们无须额外的编译步骤，而是依赖于解释执行器进行解析并执行。</p>
<p>为了让该解释执行器能够高效地运行大型程序，语言实现开发人员通常会将其包装在虚拟机里，并实现诸如即时编译、垃圾回收等其他组件。这些组件对语言设计 本身并无太大贡献，仅仅是为了实用性而不得不进行的工程实现。</p>
<p>在理想情况下，我们希望在不同的语言实现中复用这些组件。也就是说，每当开发一门新语言时，我们只需要实现它的解释执行器，便能够直接复用即时编译、垃圾回收等组件，从而达到高性能的效果。这也是 Truffle 项目的目标。接下来，我们就来讲讲这个项目。</p>
<h1 id="Truffle-项目简介"><a href="#Truffle-项目简介" class="headerlink" title="Truffle 项目简介"></a>Truffle 项目简介</h1><p>Truffle 是一个用 Java 写就的语言实现框架。基于 Truffle 的语言实现仅需用 Java 实现词法分析、语法分析以及针对语法分析所生成的抽象语法树（Abstract Syntax Tree，AST）的解释执行器，便可以享用由 Truffle 提供的各项运行时优化。</p>
<p>就一个完整的 Truffle 语言实现而言，由于实现本身以及其所依赖的 Truffle 框架部分都是用 Java 实现的，因此它可以运行在任何 Java 虚拟机之上。</p>
<p>当然，如果 Truffle 运行在附带了 Graal 编译器的 Java 虚拟机之上，那么它将调用 Graal 编译器所提供的 API，主动触发对 Truffle 语言的即时编译，将对 AST 的解释执行转换为执行即时编译后的机器码。</p>
<p>在这种情况下，Graal 编译器相当于一个提供了即时编译功能的库，宿主虚拟机本身仍可使用 C2 作为其唯一的即时编译器，或者分层编译模式下的 4 层编译器。</p>
<p><img src="/images/2020/01/23/f1494030-3dc6-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>我们团队实现并且开源了多个 Truffle 语言，例如<a href="https://github.com/graalvm/graaljs">JavaScript</a>，<a href="https://github.com/oracle/truffleruby">Ruby</a>，<a href="https://github.com/oracle/fastr">R</a>，<a href="https://github.com/graalvm/graalpython">Python</a>，以及可用来解释执行 LLVM bitcode 的Sulong。关于 Sulong 项目，任何能够编译为 LLVM bitcode 的编程语言，例如 C&#x2F;C++，都能够在这上面运行。</p>
<p>下图展示了运行在 GraalVM EE 上的 Java 虚拟机语言，以及除 Python 外 Truffle 语言的峰值性能指标（2017 年数据）。</p>
<p><img src="/images/2020/01/23/140fafa0-3dc7-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<h2 id="这里我采用的基线是每个语言较有竞争力的语言实现。"><a href="#这里我采用的基线是每个语言较有竞争力的语言实现。" class="headerlink" title="这里我采用的基线是每个语言较有竞争力的语言实现。"></a>这里我采用的基线是每个语言较有竞争力的语言实现。</h2><ul>
<li>对于 Java 虚拟机语言（Java、Scala），我比较的是使用 C2 的 HotSpot 虚拟机和使用 Graal 的 HotSpot 虚拟机。</li>
<li>对于 Ruby，我比较的是运行在 HotSpot 虚拟机之上的 JRuby 和 Truffle Ruby。</li>
<li>对于 R，我比较的是 GNU R 和基于 Truffle 的 FastR。</li>
<li>对于 C&#x2F;C++，我比较的是利用 LLVM 编译器生成的二进制文件和基于 Truffle 的 Sulong。</li>
<li>对于 JavaScript，我比较的是 Google 的 V8 和 Graal.js。</li>
</ul>
<p>针对每种语言，我们运行了上百个基准测试，求出各个基准测试<strong>峰值性能</strong>的加速比，并且汇总成图中所示的几何平均值（Geo. mean）。</p>
<p>简单地说明一下，当 GraalVM 的加速比为 1 时，代表使用其他语言实现和使用 GraalVM 的性能相当。当 GraalVM 加速比超过 1 时，则代表 GraalVM 的性能较好；反之，则说明 GraalVM 的性能较差。</p>
<p>我们可以看到，Java 跑在 Graal 上和跑在 C2 上的执行效率类似，而 Scala 跑在 Graal 上的执行效率则是跑在 C2 上的 1.2 倍。</p>
<p>对于 Ruby 或者 R 这类解释型语言，经由 Graal 编译器加速的 Truffle 语言解释器的性能十分优越，分别达到对应基线的 4.1x 和 4.5x。这里便可以看出使用专业即时编译器的 Truffle 框架的优势所在。</p>
<p>不过，对于同样拥有专业即时编译器的 V8 来说，基于 Truffle 的 Graal.js 仍处于追赶者的位置。考虑到我们团队中负责 Graal.js 的工程师仅有个位数，能够达到如此性能已属不易。现在 Graal.js 已经开源出来，我相信借助社区的贡献，它的性能能够得到进一步的提升。</p>
<p>Sulong 与传统的 C&#x2F;C++ 相比，由于两者最终都将编译为机器码，因此原则上后者定义了前者的性能上限。</p>
<p>不过，Sulong 将 C&#x2F;C++ 代码放在托管环境中运行，所有代码中的内存访问都会在托管环境的监控之下。无论是会触发 Segfault 的异常访问，还是读取敏感数据的恶意访问，都能够被 Sulong 拦截下来并作出相应处理。</p>
<h1 id="Partial-Evaluation"><a href="#Partial-Evaluation" class="headerlink" title="Partial Evaluation"></a>Partial Evaluation</h1><p>如果要理解 Truffle 的原理，我们需要先了解 Partial Evaluation 这一个概念。</p>
<p>假设有一段程序P，它将一系列输入I转换成输出O（即P: I -&gt; O）。而这些输入又可以进一步划分为编译时已知的常量IS，和编译时未知的ID。</p>
<p>那么，我们可以将程序P: I -&gt; O转换为等价的另一段程序P’: ID -&gt; O。这个新程序P’便是P的特化（Specialization），而从P转换到P’的这个过程便是所谓的 Partial Evaluation。</p>
<p>回到 Truffle 这边，我们可以将 Truffle 语言的解释执行器当成P，将某段用 Truffle 语言写就的程序当作IS，并通过 Partial Evaluation 特化为P’。由于 Truffle 语言的解释执行器是用 Java 写的，因此我们可以利用 Graal 编译器将P’编译为二进制码。</p>
<p>下面我将用一个具体例子来讲解。</p>
<p>假设有一门语言 X，只支持读取整数参数和整数加法。这两种操作分别对应下面这段代码中的 AST 节点Arg和Add。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span>[] args)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arg</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line"> </span><br><span class="line">  Arg(<span class="type">int</span> i) &#123; <span class="built_in">this</span>.index = i; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span>[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Node left, right;</span><br><span class="line"> </span><br><span class="line">  Add(Node left, Node right) &#123;</span><br><span class="line">    <span class="built_in">this</span>.left = left;</span><br><span class="line">    <span class="built_in">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span>[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> left.execute(args) +</span><br><span class="line">           right.execute(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Node node, <span class="type">int</span>[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> node.execute(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓 AST 节点的解释执行，便是调用这些 AST 节点的execute方法；而一段程序的解释执行，则是调用这段程序的 AST 根节点的execute方法。</p>
<p>我们可以看到，Arg节点和Add节点均实现了execute方法，接收一个用来指代程序输入的 int 数组参数，并返回计算结果。其中，Arg节点将返回 int 数组的第i个参数（i是硬编码在程序之中的常量）；而Add节点将分别调用左右两个节点的execute方法， 并将所返回的值相加后再返回。</p>
<p>下面我们将利用语言 X 实现一段程序，计算三个输入参数之和arg0 + arg1 + arg2。这段程序解析生成的 AST 如下述代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sample program: arg0 + arg1 + arg2</span></span><br><span class="line">sample = <span class="keyword">new</span> <span class="title class_">Add</span>(<span class="keyword">new</span> <span class="title class_">Add</span>(<span class="keyword">new</span> <span class="title class_">Arg</span>(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Arg</span>(<span class="number">1</span>)), <span class="keyword">new</span> <span class="title class_">Arg</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>这段程序对应的解释执行则是interpret(sample, args)，其中args为代表传入参数的 int 数组。由于sample是编译时常量，因此我们可以将其通过 Partial Evaluation，特化为下面这段代码所示的interpret0方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Add</span>(<span class="keyword">new</span> <span class="title class_">Add</span>(<span class="keyword">new</span> <span class="title class_">Arg</span>(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Arg</span>(<span class="number">1</span>)), <span class="keyword">new</span> <span class="title class_">Arg</span>(<span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">interpret0</span><span class="params">(<span class="type">int</span>[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> sample.execute(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Truffle 的 Partial Evaluator 会不断进行方法内联（直至遇到被&#96;&#96;@TruffleBoundary注解的方法）。因此，上面这段代码的interpret0方法，在内联了对Add.execute&#96;方法的调用之后，会转换成下述代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Add</span>(<span class="keyword">new</span> <span class="title class_">Add</span>(<span class="keyword">new</span> <span class="title class_">Arg</span>(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Arg</span>(<span class="number">1</span>)), <span class="keyword">new</span> <span class="title class_">Arg</span>(<span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">interpret0</span><span class="params">(<span class="type">int</span>[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> sample.left.execute(args) + sample.right.execute(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，我们可以进一步内联对Add.execute方法的调用以及对Arg.execute方法的调用，最终将interpret0转换成下述代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">interpret0</span><span class="params">(<span class="type">int</span>[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> args[<span class="number">0</span>] + args[<span class="number">1</span>] + args[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们已成功地将一段 Truffle 语言代码的解释执行转换为上述 Java 代码。接下来，我们便可以让 Graal 编译器将这段 Java 代码编译为机器码，从而实现 Truffle 语言的即时编译。</p>
<h1 id="节点重写"><a href="#节点重写" class="headerlink" title="节点重写"></a>节点重写</h1><p>Truffle 的另一项关键优化是节点重写（node rewriting）。</p>
<p>在动态语言中，许多变量的类型是在运行过程中方能确定的。以加法符号+为例，它既可以表示整数加法，还可以表示浮点数加法，甚至可以表示字符串加法。</p>
<p>如果是静态语言，我们可以通过推断加法的两个操作数的具体类型，来确定该加法的类型。但对于动态语言来说，我们需要在运行时动态确定操作数的具体类型，并据此选择对应的加法操作。这种在运行时选择语义的节点，会十分不利于即时编译，从而严重影响到程序的性能。</p>
<p>Truffle 语言解释器会收集每个 AST 节点所代表的操作的类型，并且在即时编译时，作出针对所收集得到的类型 profile 的特化（specialization）。</p>
<p>还是以加法操作为例，如果所收集的类型 profile 显示这是一个整数加法操作，那么在即时编译时我们会将对应的 AST 节点当成整数加法；如果是一个字符串加法操作，那么我们会将对应的 AST 节点当成字符串加法。</p>
<p>当然，如果该加法操作既有可能是整数加法也可能是字符串加法，那么我们只好在运行过程中判断具体的操作类型，并选择相应的加法操作。</p>
<p><img src="/images/2020/01/23/7c2b4c20-3dc7-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>这种基于类型 profile 的优化，与我们以前介绍过的 Java 虚拟机中解释执行器以及三层 C1 编译代码十分类似，它们背后的核心都是基于假设的投机性优化，以及在假设失败时的去优化。</p>
<p>在即时编译过后，如果运行过程中发现 AST 节点的实际类型和所假设的类型不同，Truffle 会主动调用 Graal 编译器提供的去优化 API，返回至解释执行 AST 节点的状态，并且重新收集 AST 节点的类型信息。之后，Truffle 会再次利用 Graal 编译器进行新一轮的即时编译。</p>
<p>当然，如果能够在第一次编译时便已达到稳定状态，不再触发去优化以及重新编译，那么，这会极大地减短程序到达峰值性能的时间。为此，我们统计了各个 Truffle 语言的方法在进行过多少次方法调用后，其 AST 节点的类型会固定下来。</p>
<p>据统计，在 JavaScript 方法和 Ruby 方法中，80% 会在 5 次方法调用后稳定下来，90% 会在 7 次调用后稳定下来，99% 会在 19 次方法调用之后稳定下来。</p>
<p>R 语言的方法则比较特殊，即便是不进行任何调用，有 50% 的方法已经稳定下来了。这背后的原因也不难推测，这是因为 R 语言主要用于数值统计，几乎所有的操作都是浮点数类型的。</p>
<h1 id="Polyglot"><a href="#Polyglot" class="headerlink" title="Polyglot"></a>Polyglot</h1><p>在开发过程中，我们通常会为工程项目选定一门语言，但问题也会接踵而至：一是这门语言没有实现我们可能需要用到的库，二是这门语言并不适用于某类问题。</p>
<p>Truffle 语言实现框架则支持 Polyglot，允许在同一段代码中混用不同的编程语言，从而使得开发人员能够自由地选择合适的语言来实现子组件。</p>
<p>与其他 Polyglot 框架不同的是，Truffle 语言之间能够共用对象。也就是说，在不对某个语言中的对象进行复制或者序列化反序列化的情况下，Truffle 可以无缝地将该对象传递给另一门语言。因此，Truffle 的 Polyglot 在切换语言时，性能开销非常小，甚至经常能够达到零开销。</p>
<p>Truffle 的 Polyglot 特性是通过 Polyglot API 来实现的。每个实现了 Polyglot API 的 Truffle 语言，其对象都能够被其他 Truffle 语言通过 Polyglot API 解析。实际上，当通过 Polyglot API 解析外来对象时，我们并不需要了解对方语言，便能够识别其数据结构，访问其中的数据，并进行进一步的计算。</p>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>今天我介绍了 GraalVM 中的 Truffle 项目。</p>
<p>Truffle 是一个语言实现框架，允许语言开发者在仅实现词法解析、语法解析以及 AST 解释器的情况下，达到极佳的性能。目前 Oracle Labs 已经实现并维护了 JavaScript、Ruby、R、Python 以及可用于解析 LLVM bitcode 的 Sulong。后者将支持在 GraalVM 上运行 C&#x2F;C++ 代码。</p>
<p>Truffle 背后所依赖的技术是 Partial Evaluation 以及节点重写。Partial Evaluation 指的是将所要编译的目标程序解析生成的抽象语法树当做编译时常量，特化该 Truffle 语言的解释器，从而得到指代这段程序解释执行过程的 Java 代码。然后，我们可以借助 Graal 编译器将这段 Java 代码即时编译为机器码。</p>
<p>节点重写则是收集 AST 节点的类型，根据所收集的类型 profile 进行的特化，并在节点类型不匹配时进行去优化并重新收集、编译的一项技术。</p>
<p>Truffle 的 Polyglot 特性支持在一段代码中混用多种不同的语言。与其他 Polyglot 框架相比，它支持在不同的 Truffle 语言中复用内存中存储的同一个对象。</p>
<p>今天的实践环节，请你试用 GraalVM 中附带的各项语言实现。你可以运行我们官网上的各个<a href="https://www.graalvm.org/docs/examples/">示例程序</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-34/" class="post-title-link" itemprop="url">34 | Graal：用Java编译Java</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 17:56:24" itemprop="dateCreated datePublished" datetime="2020-01-23T17:56:24+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-EdwzzDYp" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-EdwzzDYp"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频34",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/60/f3/6003fa06d5a4a1509ccddada9ec037f3.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>最后这三篇文章，我将介绍 Oracle Labs 的 GraalVM 项目。</p>
<p>GraalVM 是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK 上运行，也可以通过 AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。</p>
<p>除此之外，它还移除了编程语言之间的边界，并且支持通过即时编译技术，将混杂了不同的编程语言的代码编译到同一段二进制码之中，从而实现不同语言之间的无缝切换。</p>
<p>今天这一篇，我们就来讲讲 GraalVM 的基石 Graal 编译器。</p>
<p>在之前的篇章中，特别是介绍即时编译技术的第二部分，我们反反复复提到了 Graal 编译器。这是一个用 Java 写就的即时编译器，它从 Java 9u 开始便被集成自 JDK 中，作为实验性质的即时编译器。</p>
<p>Graal 编译器可以通过 Java 虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉 HotSpot 中的 C2 编译器，并响应原本由 C2 负责的编译请求。</p>
<p>在今天的文章中，我将详细跟你介绍一下 Graal 与 Java 虚拟机的交互、Graal 和 C2 的区别以及 Graal 的实现细节。</p>
<h1 id="Graal-和-Java-虚拟机的交互"><a href="#Graal-和-Java-虚拟机的交互" class="headerlink" title="Graal 和 Java 虚拟机的交互"></a>Graal 和 Java 虚拟机的交互</h1><p>我们知道，即时编译器是 Java 虚拟机中相对独立的模块，它主要负责接收 Java 字节码，并生成可以直接运行的二进制码。</p>
<p>具体来说，即时编译器与 Java 虚拟机的交互可以分为如下三个方面。</p>
<p>响应编译请求；<br>获取编译所需的元数据（如类、方法、字段）和反映程序执行状态的 profile；<br>将生成的二进制码部署至代码缓存（code cache）里。<br>即时编译器通过这三个功能组成了一个响应编译请求、获取编译所需的数据，完成编译并部署的完整编译周期。</p>
<p>传统情况下，即时编译器是与 Java 虚拟机紧耦合的。也就是说，对即时编译器的更改需要重新编译整个 Java 虚拟机。这对于开发相对活跃的 Graal 来说显然是不可接受的。</p>
<p>为了让 Java 虚拟机与 Graal 解耦合，我们引入了<a href="http://openjdk.java.net/jeps/243">Java 虚拟机编译器接口</a>（JVM Compiler Interface，JVMCI），将上述三个功能抽象成一个 Java 层面的接口。这样一来，在 Graal 所依赖的 JVMCI 版本不变的情况下，我们仅需要替换 Graal 编译器相关的 jar 包（Java 9 以后的 jmod 文件），便可完成对 Graal 的升级。</p>
<p>JVMCI 的作用并不局限于完成由 Java 虚拟机发出的编译请求。实际上，Java 程序可以直接调用 Graal，编译并部署指定方法。</p>
<p>Graal 的单元测试便是基于这项技术。为了测试某项优化是否起作用，原本我们需要反复运行某一测试方法，直至 Graal 收到由 Java 虚拟机发出针对该方法的编译请求，而现在我们可以直接指定编译该方法，并进行测试。我们下一篇将介绍的 Truffle 语言实现框架，同样也是基于这项技术的。</p>
<h1 id="Graal-和-C2-的区别"><a href="#Graal-和-C2-的区别" class="headerlink" title="Graal 和 C2 的区别"></a>Graal 和 C2 的区别</h1><p>Graal 和 C2 最为明显的一个区别是：Graal 是用 Java 写的，而 C2 是用 C++ 写的。相对来说，Graal 更加模块化，也更容易开发与维护，毕竟，连 C2 的作者 Cliff Click 大神都不想重蹈用 C++ 开发 Java 虚拟机的覆辙。</p>
<p>许多开发者会觉得用 C++ 写的 C2 肯定要比 Graal 快。实际上，在充分预热的情况下，Java 程序中的热点代码早已经通过即时编译转换为二进制码，在执行速度上并不亚于静态编译的 C++ 程序。</p>
<p>再者，即便是解释执行 Graal，也仅是会减慢编译效率，而并不影响编译结果的性能。</p>
<p>换句话说，如果 C2 和 Graal 采用相同的优化手段，那么它们的编译结果是一样的。所以，程序达到稳定状态（即不再触发新的即时编译）的性能，也就是峰值性能，将也是一样的。</p>
<p>由于 Java 语言容易开发维护的优势，我们可以很方便地将 C2 的新优化移植到 Graal 中。反之则不然，比如，在 Graal 中被证实有效的部分逃逸分析（partial escape analysis）至今未被移植到 C2 中。</p>
<p>Graal 和 C2 另一个优化上的分歧则是方法内联算法。相对来说，Graal 的内联算法对新语法、新语言更加友好，例如 Java 8 的 lambda 表达式以及 Scala 语言。</p>
<p>我们曾统计过数十个 Java 或 Scala 程序的峰值性能。总体而言，Graal 编译结果的性能要优于 C2。对于 Java 程序来说，Graal 的优势并不明显；对于 Scala 程序来说，Graal 的性能优势达到了 10%。</p>
<p>大规模使用 Scala 的 Twitter 便在他们的生产环境中部署了 Graal 编译器，并取得了 11% 的性能提升。（<a href="https://downloads.ctfassets.net/oxjq45e8ilak/6eh2A72b4IyWsWOIcig4K0/cbb664566fe86672d92ddfb210623920/Chris_Thalinger_Twitter_s_quest_for_a_wholly_Graal_runtime.pdf">Slides</a>, <a href="https://youtu.be/G-vlQaPMAxg?t=20m15s">Video</a>，该数据基于 GraalVM 社区版。）</p>
<h1 id="Graal-的实现"><a href="#Graal-的实现" class="headerlink" title="Graal 的实现"></a>Graal 的实现</h1><p>Graal 编译器将编译过程分为前端和后端两大部分。前端用于实现平台无关的优化（如方法内联），以及小部分平台相关的优化；而后端则负责大部分的平台相关优化（如寄存器分配），以及机器码的生成。</p>
<p>在介绍即时编译技术时，我曾提到过，Graal 和 C2 都采用了 Sea-of-Nodes IR。严格来说，这里指的是 Graal 的前端，而后端采用的是另一种非 Sea-of-Nodes 的 IR。通常，我们将前端的 IR 称之为 High-level IR，或者 HIR；后端的 IR 则称之为 Low-level IR，或者 LIR。</p>
<p>Graal 的前端是由一个个单独的优化阶段（optimization phase）构成的。我们可以将每个优化阶段想象成一个图算法：它会接收一个规则的图，遍历图上的节点并做出优化，并且返回另一个规则的图。前端中的编译阶段除了少数几个关键的之外，其余均可以通过配置选项来开启或关闭。</p>
<p><img src="/images/2020/01/23/57070c00-3dc6-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>Graal 编译器前端的优化阶段（局部）</p>
<blockquote>
<p>感兴趣的同学可以阅读 Graal repo 里配置这些编译优化阶段的源文件<br><a href="https://github.com/oracle/graal/blob/master/compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/phases/HighTier.java">HighTier.java</a>，<a href="https://github.com/oracle/graal/blob/master/compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/phases/MidTier.java">MidTier.java</a>，以及<a href="https://github.com/oracle/graal/blob/master/compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/phases/LowTier.java">LowTier.java</a>。</p>
</blockquote>
<p>我们知道，Graal 和 C2 都采用了激进的投机性优化手段（speculative optimization）。</p>
<p>通常，这些优化都基于某种假设（assumption）。当假设出错的情况下，Java 虚拟机会借助去优化（deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序 profile 之后，再进行编译。</p>
<p>举个以前讲过的例子，类层次分析。在进行虚方法内联时（或者其他与类层次相关的优化），我们可能会发现某个接口仅有一个实现。</p>
<p>在即时编译过程中，我们可以假设在之后的执行过程中仍旧只有这一个实现，并根据这个假设进行编译优化。当之后加载了接口的另一实现时，我们便会废弃这份机器码。</p>
<p>Graal 与 C2 相比会更加激进。它从设计上便十分青睐这种基于假设的优化手段。在编译过程中，Graal 支持自定义假设，并且直接与去优化节点相关联。</p>
<p>当对应的去优化被触发时，Java 虚拟机将负责记录对应的自定义假设。而 Graal 在第二次编译同一方法时，便会知道该自定义假设有误，从而不再对该方法使用相同的激进优化。</p>
<p>Java 虚拟机的另一个能够大幅度提升性能的特性是 intrinsic 方法，我在之前的篇章中已经详细介绍过了。在 Graal 中，实现高性能的 intrinsic 方法也相对比较简单。Graal 提供了一种替换方法调用的机制，在解析 Java 字节码时会将匹配到的方法调用，替换成对另一个内部方法的调用，或者直接替换为特殊节点。</p>
<p>举例来说，我们可以把比较两个 byte 数组的方法java.util.Arrays.equals(byte[],byte[])替换成一个特殊节点，用来代表整个数组比较的逻辑。这样一来，当前编译方法所对应的图将被简化，因而其适用于其他优化的可能性也将提升。</p>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>Graal 是一个用 Java 写就的、并能够将 Java 字节码转换成二进制码的即时编译器。它通过 JVMCI 与 Java 虚拟机交互，响应由后者发出的编译请求、完成编译并部署编译结果。</p>
<p>对 Java 程序而言，Graal 编译结果的性能略优于 OpenJDK 中的 C2；对 Scala 程序而言，它的性能优势可达到 10%（企业版甚至可以达到 20%！）。这背后离不开 Graal 所采用的激进优化方式。</p>
<p>今天的实践环节，你可以尝试使用附带 Graal 编译器的 JDK。在 Java 10，11 中，你可以通过添加虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler来启用，或者下载我们部署在<a href="https://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html">Oracle OTN</a>上的基于 Java 8 的版本。</p>
<blockquote>
<p>在刚开始运行的过程中，Graal 编译器本身需要被即时编译，会抢占原本可用于编译应用代码的计算资源。因此，目前 Graal 编译器的启动性能会较差。最后一篇我会介绍解决方案。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-33/" class="post-title-link" itemprop="url">33 | Java Agent与字节码注入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 17:51:39" itemprop="dateCreated datePublished" datetime="2020-01-23T17:51:39+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-bdNVvoZJ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-bdNVvoZJ"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频33",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/c2/44/c2c03ab0bc40c20290ee2ebbb3ec8644.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>关于 Java agent，大家可能都听过大名鼎鼎的premain方法。顾名思义，这个方法指的就是在main方法之前执行的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAgent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;premain&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在上面这段代码中定义了一个premain方法。这里需要注意的是，Java 虚拟机所能识别的premain方法接收的是字符串类型的参数，而并非类似于main方法的字符串数组。</p>
<p>为了能够以 Java agent 的方式运行该premain方法，我们需要将其打包成 jar 包，并在其中的 MANIFEST.MF 配置文件中，指定所谓的Premain-class。具体的命令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意第一条命令会向 manifest.txt 文件写入两行数据，其中包括一行空行</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;Premain-Class: org.example.MyAgent</span></span><br><span class="line"><span class="string">&#x27;</span> &gt; manifest.txt</span><br><span class="line">$ jar cvmf manifest.txt myagent.jar org/</span><br><span class="line">$ java -javaagent:myagent.jar HelloWorld</span><br><span class="line">premain</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>

<p>除了在命令行中指定 Java agent 之外，我们还可以通过 Attach API 远程加载。具体用法如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttachTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Usage: java AttachTest &lt;PID&gt; /PATH/TO/AGENT.jar&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">VirtualMachine</span> <span class="variable">vm</span> <span class="operator">=</span> VirtualMachine.attach(args[<span class="number">0</span>]);</span><br><span class="line">    vm.loadAgent(args[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Attach API 远程加载的 Java agent 不会再先于main方法执行，这取决于另一虚拟机调用 Attach API 的时机。并且，它运行的也不再是premain方法，而是名为agentmain的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAgent</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;agentmain&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的，我们需要更新 jar 包中的 manifest 文件，使其包含Agent-Class的配置，例如Agent-Class: org.example.MyAgent。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;Agent-Class: org.example.MyAgent</span></span><br><span class="line"><span class="string">&#x27;</span> &gt; manifest.txt</span><br><span class="line">$ jar cvmf manifest.txt myagent.jar org/</span><br><span class="line">$ java HelloWorld</span><br><span class="line">Hello, World</span><br><span class="line">$ jps</span><br><span class="line">$ java AttachTest &lt;pid&gt; myagent.jar</span><br><span class="line">agentmain</span><br><span class="line">// 最后一句输出来自于运行 HelloWorld 的 Java 进程</span><br></pre></td></tr></table></figure>

<p>Java 虚拟机并不限制 Java agent 的数量。你可以在 java 命令后附上多个-javaagent参数，或者远程 attach 多个 Java agent，Java 虚拟机会按照定义顺序，或者 attach 的顺序逐个执行这些 Java agent。</p>
<p>在premain方法或者agentmain方法中打印一些字符串并不出奇，我们完全可以将其中的逻辑并入main方法，或者其他监听端口的线程中。除此之外，Java agent 还提供了一套 instrumentation 机制，允许应用程序拦截类加载事件，并且更改该类的字节码。</p>
<p>接下来，我们来了解一下基于这一机制的字节码注入。</p>
<h1 id="字节码注入"><a href="#字节码注入" class="headerlink" title="字节码注入"></a>字节码注入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.*;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAgent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> &#123;</span><br><span class="line">    instrumentation.addTransformer(<span class="keyword">new</span> <span class="title class_">MyTransformer</span>());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">      System.out.printf(<span class="string">&quot;Loaded %s: 0x%X%X%X%X\n&quot;</span>, className, classfileBuffer[<span class="number">0</span>], classfileBuffer[<span class="number">1</span>],</span><br><span class="line">          classfileBuffer[<span class="number">2</span>], classfileBuffer[<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看一个例子。在上面这段代码中，premain方法多出了一个Instrumentation类型的参数，我们可以通过它来注册类加载事件的拦截器。该拦截器需要实现ClassFileTransformer接口，并重写其中的transform方法。</p>
<p>transform方法将接收一个 byte 数组类型的参数，它代表的是正在被加载的类的字节码。在上面这段代码中，我将打印该数组的前四个字节，也就是 Java class 文件的魔数（magic number）0xCAFEBABE。</p>
<p>transform方法将返回一个 byte 数组，代表更新过后的类的字节码。当方法返回之后，Java 虚拟机会使用所返回的 byte 数组，来完成接下来的类加载工作。不过，如果transform方法返回 null 或者抛出异常，那么 Java 虚拟机将使用原来的 byte 数组完成类加载工作。</p>
<p>基于这一类加载事件的拦截功能，我们可以实现字节码注入（bytecode instrumentation），往正在被加载的类中插入额外的字节码。</p>
<p>在工具篇中我曾经介绍过字节码工程框架 ASM 的用法。下面我将演示它的<a href="https://search.maven.org/artifact/org.ow2.asm/asm-tree/7.0-beta/jar">tree 包</a>（依赖于<a href="https://search.maven.org/artifact/org.ow2.asm/asm/7.0-beta/jar">基础包</a>），用面向对象的方式注入字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.*;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.*;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.tree.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAgent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> &#123;</span><br><span class="line">    instrumentation.addTransformer(<span class="keyword">new</span> <span class="title class_">MyTransformer</span>());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span>, Opcodes &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">      <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(classfileBuffer);</span><br><span class="line">      <span class="type">ClassNode</span> <span class="variable">classNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNode</span>(ASM7);</span><br><span class="line">      cr.accept(classNode, ClassReader.SKIP_FRAMES);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span> (MethodNode methodNode : classNode.methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(methodNode.name)) &#123;</span><br><span class="line">          <span class="type">InsnList</span> <span class="variable">instrumentation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsnList</span>();</span><br><span class="line">          instrumentation.add(<span class="keyword">new</span> <span class="title class_">FieldInsnNode</span>(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>));</span><br><span class="line">          instrumentation.add(<span class="keyword">new</span> <span class="title class_">LdcInsnNode</span>(<span class="string">&quot;Hello, Instrumentation!&quot;</span>));</span><br><span class="line">          instrumentation</span><br><span class="line">              .add(<span class="keyword">new</span> <span class="title class_">MethodInsnNode</span>(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"> </span><br><span class="line">          methodNode.instructions.insert(instrumentation);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);</span><br><span class="line">      classNode.accept(cw);</span><br><span class="line">      <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码不难理解。我们将使用ClassReader读取所传入的 byte 数组，并将其转换成ClassNode。然后我们将遍历ClassNode中的MethodNode节点，也就是该类中的构造器和方法。</p>
<p>当遇到名字为”main”的方法时，我们会在方法的入口处注入System.out.println(“Hello, Instrumentation!”);。运行结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java -javaagent:myagent.jar -<span class="built_in">cp</span> .:/PATH/TO/asm-7.0-beta.jar:/PATH/TO/asm-tree-7.0-beta.jar HelloWorld</span><br><span class="line">Hello, Instrumentation!</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<p>Java agent 还提供了另外两个功能redefine和retransform。这两个功能针对的是已加载的类，并要求用户传入所要redefine或者retransform的类实例。</p>
<p>其中，redefine指的是舍弃原本的字节码，并替换成由用户提供的 byte 数组。该功能比较危险，一般用于修复出错了的字节码。</p>
<p>retransform则将针对所传入的类，重新调用所有已注册的ClassFileTransformer的transform方法。它的应用场景主要有如下两个。</p>
<p>第一，在执行premain或者agentmain方法前，Java 虚拟机早已加载了不少类，而这些类的加载事件并没有被拦截，因此也没有被注入。使用retransform功能可以注入这些已加载但未注入的类。</p>
<p>第二，在定义了多个 Java agent，多个注入的情况下，我们可能需要移除其中的部分注入。当调用Instrumentation.removeTransformer去除某个注入类后，我们可以调用retransform功能，重新从原始 byte 数组开始进行注入。</p>
<p>Java agent 的这些功能都是通过 JVMTI agent，也就是 C agent 来实现的。JVMTI 是一个事件驱动的工具实现接口，通常，我们会在 C agent 加载后的入口方法Agent_OnLoad处注册各个事件的钩子（hook）方法。当 Java 虚拟机触发了这些事件时，便会调用对应的钩子方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Agent_OnLoad(JavaVM *vm, char *options, void *reserved);</span><br></pre></td></tr></table></figure>

<p>举个例子，我们可以为 JVMTI 中的ClassFileLoadHook事件设置钩子，从而在 C 层面拦截所有的类加载事件。关于 JVMTI 的其他事件，你可以参考该<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html#EventIndex">链接</a>。</p>
<h1 id="基于字节码注入的-profiler"><a href="#基于字节码注入的-profiler" class="headerlink" title="基于字节码注入的 profiler"></a>基于字节码注入的 profiler</h1><p>我们可以利用字节码注入来实现代码覆盖工具（例如<a href="https://www.jacoco.org/jacoco/">JaCoCo</a>），或者各式各样的 profiler。</p>
<p>通常，我们会定义一个运行时类，并在某一程序行为的周围，注入对该运行时类中方法的调用，以表示该程序行为正要发生或者已经发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProfiler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Class&lt;?&gt;, AtomicInteger&gt; data = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fireAllocationEvent</span><span class="params">(Class&lt;?&gt; klass)</span> &#123;</span><br><span class="line">    data.computeIfAbsent(klass, kls -&gt; <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>())</span><br><span class="line">        .incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dump</span><span class="params">()</span> &#123;</span><br><span class="line">    data.forEach((kls, counter) -&gt; &#123;</span><br><span class="line">      System.err.printf(<span class="string">&quot;%s: %d\n&quot;</span>, kls.getName(), counter.get());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(MyProfiler::dump));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，上面这段代码便是一个运行时类。该类维护了一个HashMap，用来统计每个类所新建实例的数目。当程序退出时，我们将逐个打印出每个类的名字，以及其新建实例的数目。</p>
<p>在 Java agent 中，我们会截获正在加载的类，并且在每条new字节码之后插入对fireAllocationEvent方法的调用，以表示当前正在新建某个类的实例。具体的注入代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.*;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.*;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.tree.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAgent</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> &#123;</span><br><span class="line">    instrumentation.addTransformer(<span class="keyword">new</span> <span class="title class_">MyTransformer</span>());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span>, Opcodes &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">      <span class="keyword">if</span> (className.startsWith(<span class="string">&quot;java&quot;</span>)    ||</span><br><span class="line">          className.startsWith(<span class="string">&quot;javax&quot;</span>)   || </span><br><span class="line">          className.startsWith(<span class="string">&quot;jdk&quot;</span>)     ||</span><br><span class="line">          className.startsWith(<span class="string">&quot;sun&quot;</span>)     ||</span><br><span class="line">          className.startsWith(<span class="string">&quot;com/sun&quot;</span>) ||</span><br><span class="line">          className.startsWith(<span class="string">&quot;org/example&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Skip JDK classes and profiler classes</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(classfileBuffer);</span><br><span class="line">      <span class="type">ClassNode</span> <span class="variable">classNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNode</span>(ASM7);</span><br><span class="line">      cr.accept(classNode, ClassReader.SKIP_FRAMES);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span> (MethodNode methodNode : classNode.methods) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AbstractInsnNode node : methodNode.instructions.toArray()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (node.getOpcode() == NEW) &#123;</span><br><span class="line">            <span class="type">TypeInsnNode</span> <span class="variable">typeInsnNode</span> <span class="operator">=</span> (TypeInsnNode) node;</span><br><span class="line"> </span><br><span class="line">            <span class="type">InsnList</span> <span class="variable">instrumentation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsnList</span>();</span><br><span class="line">            instrumentation.add(<span class="keyword">new</span> <span class="title class_">LdcInsnNode</span>(Type.getObjectType(typeInsnNode.desc)));</span><br><span class="line">            instrumentation.add(<span class="keyword">new</span> <span class="title class_">MethodInsnNode</span>(INVOKESTATIC, <span class="string">&quot;org/example/MyProfiler&quot;</span>, <span class="string">&quot;fireAllocationEvent&quot;</span>,</span><br><span class="line">                <span class="string">&quot;(Ljava/lang/Class;)V&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"> </span><br><span class="line">            methodNode.instructions.insert(node, instrumentation);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);</span><br><span class="line">      classNode.accept(cw);</span><br><span class="line">      <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你或许已经留意到，我们不得不排除对 JDK 类以及该运行时类的注入。这是因为，对这些类的注入很可能造成死循环调用，并最终抛出StackOverflowException异常。</p>
<p>举个例子，假设我们在PrintStream.println方法入口处注入System.out.println(“blahblah”)，由于out是PrintStream的实例，因此当执行注入代码时，我们又会调用PrintStream.println方法，从而造成死循环。</p>
<p>解决这一问题的关键在于设置一个线程私有的标识位，用以区分应用代码的上下文以及注入代码的上下文。当即将执行注入代码时，我们将根据标识位判断是否已经位于注入代码的上下文之中。如果不是，则设置标识位并正常执行注入代码；如果是，则直接返回，不再执行注入代码。</p>
<p>字节码注入的另一个技术难点则是命名空间。举个例子，不少应用程序都依赖于字节码工程库 ASM。当我们的注入逻辑依赖于 ASM 时，便有可能出现注入使用最新版本的 ASM，而应用程序使用较低版本的 ASM 的问题。</p>
<p>JDK 本身也使用了 ASM 库，如用来生成 Lambda 表达式的适配器类。JDK 的做法是重命名整个 ASM 库，为所有类的包名添加jdk.internal前缀。我们显然不好直接更改 ASM 的包名，因此需要借助自定义类加载器来隔离命名空间。</p>
<p>除了上述技术难点之外，基于字节码注入的工具还有另一个问题，那便是观察者效应（observer effect）对所收集的数据造成的影响。</p>
<p>举个利用字节码注入收集每个方法的运行时间的例子。假设某个方法调用了另一个方法，而这两个方法都被注入了，那么统计被调用者运行时间的注入代码所耗费的时间，将不可避免地被计入至调用者方法的运行时间之中。</p>
<p>再举一个统计新建对象数目的例子。我们知道，即时编译器中的逃逸分析可能会优化掉新建对象操作，但它不会消除相应的统计操作，比如上述例子中对fireAllocationEvent方法的调用。在这种情况下，我们将统计没有实际发生的新建对象操作。</p>
<p>另一种情况则是，我们所注入的对fireAllocationEvent方法的调用，将影响到方法内联的决策。如果该新建对象的构造器调用恰好因此没有被内联，从而造成对象逃逸。在这种情况下，原本能够被逃逸分析优化掉的新建对象操作将无法优化，我们也将统计到原本不会发生的新建对象操作。</p>
<p>总而言之，当使用字节码注入开发 profiler 时，需要辩证地看待所收集的数据。它仅能表示在被注入的情况下程序的执行状态，而非没有注入情况下的程序执行状态。</p>
<h1 id="面向方面编程"><a href="#面向方面编程" class="headerlink" title="面向方面编程"></a>面向方面编程</h1><p>说到字节码注入，就不得不提面向方面编程（Aspect-Oriented Programming，AOP）。面向方面编程的核心理念是定义切入点（pointcut）以及通知（advice）。程序控制流中所有匹配该切入点的连接点（joinpoint）都将执行这段通知代码。</p>
<p>举个例子，我们定义一个指代所有方法入口的切入点，并指定在该切入点执行的“打印该方法的名字”这一通知。那么每个具体的方法入口便是一个连接点。</p>
<p>面向方面编程的其中一种实现方式便是字节码注入，比如<a href="https://www.eclipse.org/aspectj/">AspectJ</a>。</p>
<p>在前面的例子中，我们也相当于使用了面向方面编程，在所有的new字节码之后执行了下面这样一段通知代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`MyProfiler.fireAllocationEvent(&lt;Target&gt;.class)`</span><br></pre></td></tr></table></figure>

<p>我曾经参与开发过一个应用了面向方面编程思想的字节码注入框架DiSL。它支持用注解来定义切入点，用普通 Java 方法来定义通知。例如，在方法入口处打印所在的方法名，可以简单表示为如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(marker = BodyMarker.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onMethodEntry</span><span class="params">(MethodStaticContext msc)</span> &#123;</span><br><span class="line">  System.out.println(msc.thisMethodFullName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有同学对这个工具感兴趣，或者有什么需求或者建议，欢迎你在留言中提出。</p>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>今天我介绍了 Java agent 以及字节码注入。</p>
<p>我们可以通过 Java agent 的类加载拦截功能，修改某个类所对应的 byte 数组，并利用这个修改过后的 byte 数组完成接下来的类加载。</p>
<p>基于字节码注入的 profiler，可以统计程序运行过程中某些行为的出现次数。如果需要收集 Java 核心类库的数据，那么我们需要小心避免无限递归调用。另外，我们还需通过自定义类加载器来解决命名空间的问题。</p>
<p>由于字节码注入会产生观察者效应，因此基于该技术的 profiler 所收集到的数据并不能反映程序的真实运行状态。它所反映的是程序在被注入的情况下的执行状态。</p>
<p>今天的实践环节，请你思考如何注入方法出口。除了正常执行路径之外，你还需考虑异常执行路径。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-32/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-32/" class="post-title-link" itemprop="url">32 | JNI的运行机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 17:45:26" itemprop="dateCreated datePublished" datetime="2020-01-23T17:45:26+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-vsiJyZiS" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-vsiJyZiS"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频32",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/83/22/835e43c39382b3f56e7466537b3d5622.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们经常会遇见 Java 语言较难表达，甚至是无法表达的应用场景。比如我们希望使用汇编语言（如 X86_64 的 SIMD 指令）来提升关键代码的性能；再比如，我们希望调用 Java 核心类库无法提供的，某个体系架构或者操作系统特有的功能。</p>
<p>在这种情况下，我们往往会牺牲可移植性，在 Java 代码中调用 C&#x2F;C++ 代码（下面简述为 C 代码），并在其中实现所需功能。这种跨语言的调用，便需要借助 Java 虚拟机的 Java Native Interface（JNI）机制。</p>
<p>关于 JNI 的例子，你应该特别熟悉 Java 中标记为native的、没有方法体的方法（下面统称为 native 方法）。当在 Java 代码中调用这些 native 方法时，Java 虚拟机将通过 JNI，调用至对应的 C 函数（下面将 native 方法对应的 C 实现统称为 C 函数）中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，Object.hashCode方法便是一个 native 方法。它对应的 C 函数将计算对象的哈希值，并缓存在对象头、栈上锁记录（轻型锁）或对象监视锁（重型锁所使用的 monitor）中，以确保该值在对象的生命周期之内不会变更。</p>
<h1 id="native-方法的链接"><a href="#native-方法的链接" class="headerlink" title="native 方法的链接"></a>native 方法的链接</h1><p>在调用 native 方法前，Java 虚拟机需要将该 native 方法链接至对应的 C 函数上。</p>
<p>链接方式主要有两种。第一种是让 Java 虚拟机自动查找符合默认命名规范的 C 函数，并且链接起来。</p>
<p>事实上，我们并不需要记住所谓的命名规范，而是采用javac -h命令，便可以根据 Java 程序中的 native 方法声明，自动生成包含符合命名规范的 C 函数的头文件。</p>
<p>举个例子，在下面这段代码中，Foo类有三个 native 方法，分别为静态方法foo以及两个重载的实例方法bar。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> i, <span class="type">long</span> j)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(String s, Object o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过执行javac -h . org&#x2F;example&#x2F;Foo.java命令，我们将在当前文件夹（对应-h后面跟着的.）生成名为org_example_Foo.h的头文件。其内容如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line"><span class="comment">/* Header for class org_example_Foo */</span></span><br><span class="line"> </span><br><span class="line">#ifndef _Included_org_example_Foo</span><br><span class="line">#define _Included_org_example_Foo</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">#endif</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     org_example_Foo</span></span><br><span class="line"><span class="comment"> * Method:    foo</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_org_example_Foo_foo</span></span><br><span class="line">  <span class="params">(JNIEnv *, jclass)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     org_example_Foo</span></span><br><span class="line"><span class="comment"> * Method:    bar</span></span><br><span class="line"><span class="comment"> * Signature: (IJ)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_org_example_Foo_bar__IJ</span></span><br><span class="line">  <span class="params">(JNIEnv *, jobject, jint, jlong)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     org_example_Foo</span></span><br><span class="line"><span class="comment"> * Method:    bar</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;Ljava/lang/Object;)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span></span><br><span class="line">  <span class="params">(JNIEnv *, jobject, jstring, jobject)</span>;</span><br><span class="line"> </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>这里我简单讲解一下该命名规范。</p>
<p>首先，native 方法对应的 C 函数都需要以Java_为前缀，之后跟着完整的包名和方法名。由于 C 函数名不支持&#x2F;字符，因此我们需要将&#x2F;转换为_，而原本方法名中的_符号，则需要转换为_1。</p>
<p>举个例子，org.example包下Foo类的foo方法，Java 虚拟机会将其自动链接至名为Java_org_example_Foo_foo的 C 函数中。</p>
<p>当某个类出现重载的 native 方法时，Java 虚拟机还会将参数类型纳入自动链接对象的考虑范围之中。具体的做法便是在前面 C 函数名的基础上，追加__以及方法描述符作为后缀。</p>
<p>方法描述符的特殊符号同样会被替换掉，如引用类型所使用的;会被替换为_2，数组类型所使用的[会被替换为_3。</p>
<p>基于此命名规范，你可以手动拼凑上述代码中，Foo类的两个bar方法所能自动链接的 C 函数名，并用javac -h命令所生成的结果来验证一下。</p>
<p>第二种链接方式则是在 C 代码中主动链接。</p>
<p>这种链接方式对 C 函数名没有要求。通常我们会使用一个名为registerNatives的 native 方法，并按照第一种链接方式定义所能自动链接的 C 函数。在该 C 函数中，我们将手动链接该类的其他 native 方法。</p>
<p>举个例子，Object类便拥有一个registerNatives方法，所对应的 C 代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：Object 类的 registerNatives 方法的实现位于 java.base 模块里的 C 代码中</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hashCode&quot;</span>,    <span class="string">&quot;()I&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;wait&quot;</span>,        <span class="string">&quot;(J)V&quot;</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;notify&quot;</span>,      <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;notifyAll&quot;</span>,   <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;clone&quot;</span>,       <span class="string">&quot;()Ljava/lang/Object;&quot;</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_java_lang_Object_registerNatives</span><span class="params">(JNIEnv *env, jclass cls)</span></span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls,</span><br><span class="line">                            methods, sizeof(methods)/sizeof(methods[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，上面这段代码中的 C 函数将调用RegisterNatives API，注册Object类中其他 native 方法所要链接的 C 函数。并且，这些 C 函数的名字并不符合默认命名规则。</p>
<p>当使用第二种方式进行链接时，我们需要在其他 native 方法被调用之前完成链接工作。因此，我们往往会在类的初始化方法里调用该registerNatives方法。具体示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们采用第一种链接方式，并且实现其中的bar(String, Object)方法。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include <span class="string">&quot;org_example_Foo.h&quot;</span></span><br><span class="line"> </span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span></span><br><span class="line">  <span class="params">(JNIEnv *env, jobject thisObject, jstring str, jobject obj)</span> &#123;</span><br><span class="line">  printf(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们可以通过 gcc 命令将其编译成为动态链接库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该命令仅适用于 macOS</span></span><br><span class="line">$ gcc -I<span class="variable">$JAVA_HOME</span>/include -I<span class="variable">$JAVA_HOME</span>/include/darwin -o libfoo.dylib -shared foo.c</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，动态链接库的名字须以lib为前缀，以.dylib(或 Linux 上的.so）为扩展名。在 Java 程序中，我们可以通过System.loadLibrary(“foo”)方法来加载libfoo.dylib，如下述代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> i, <span class="type">long</span> j)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(String s, Object o)</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0xDEADBEEF</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.loadLibrary(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsatisfiedLinkError e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Foo</span>().bar(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果libfoo.dylib不在当前路径下，我们可以在启动 Java 虚拟机时配置java.library.path参数，使其指向包含libfoo.dylib的文件夹。具体命令如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -Djava.library.path=/PATH/TO/DIR/CONTAINING/libfoo.dylib org.example.Foo</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>

<h1 id="JNI-的-API"><a href="#JNI-的-API" class="headerlink" title="JNI 的 API"></a>JNI 的 API</h1><p>在 C 代码中，我们也可以使用 Java 的语言特性，如 instanceof 测试等。这些功能都是通过特殊的 JNI 函数（<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/functions.html">JNI Functions</a>）来实现的。</p>
<p>Java 虚拟机会将所有 JNI 函数的函数指针聚合到一个名为JNIEnv的数据结构之中。</p>
<p>这是一个线程私有的数据结构。Java 虚拟机会为每个线程创建一个JNIEnv，并规定 C 代码不能将当前线程的JNIEnv共享给其他线程，否则 JNI 函数的正确性将无法保证。</p>
<p>这么设计的原因主要有两个。一是给 JNI 函数提供一个单独命名空间。二是允许 Java 虚拟机通过更改函数指针替换 JNI 函数的具体实现，例如从附带参数类型检测的慢速版本，切换至不做参数类型检测的快速版本。</p>
<p>在 HotSpot 虚拟机中，JNIEnv被内嵌至 Java 线程的数据结构之中。部分虚拟机代码甚至会从JNIEnv的地址倒推出 Java 线程的地址。因此，如果在其他线程中使用当前线程的JNIEnv，会使这部分代码错误识别当前线程。</p>
<p>JNI 会将 Java 层面的基本类型以及引用类型映射为另一套可供 C 代码使用的数据结构。其中，基本类型的对应关系如下表所示：</p>
<p>引用类型对应的数据结构之间也存在着继承关系，具体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jobject</span><br><span class="line">|- jclass (java.lang.Class objects)</span><br><span class="line">|- jstring (java.lang.String objects)</span><br><span class="line">|- jthrowable (java.lang.Throwable objects)</span><br><span class="line">|- jarray (arrays)</span><br><span class="line">   |- jobjectArray (object arrays)</span><br><span class="line">   |- jbooleanArray (boolean arrays)</span><br><span class="line">   |- jbyteArray (byte arrays)</span><br><span class="line">   |- jcharArray (<span class="type">char</span> arrays)</span><br><span class="line">   |- jshortArray (<span class="type">short</span> arrays)</span><br><span class="line">   |- jintArray (<span class="type">int</span> arrays)</span><br><span class="line">   |- jlongArray (<span class="type">long</span> arrays)</span><br><span class="line">   |- jfloatArray (<span class="type">float</span> arrays)</span><br><span class="line">   |- jdoubleArray (<span class="type">double</span> arrays)</span><br></pre></td></tr></table></figure>

<p>我们回头看看Foo类 3 个 native 方法对应的 C 函数的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_org_example_Foo_foo</span></span><br><span class="line">  <span class="params">(JNIEnv *, jclass)</span>;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_org_example_Foo_bar__IJ</span></span><br><span class="line">  <span class="params">(JNIEnv *, jobject, jint, jlong)</span>;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span>  <span class="params">(JNIEnv *, jobject, jstring, jobject)</span>;</span><br></pre></td></tr></table></figure>

<p>静态 native 方法foo将接收两个参数，分别为存放 JNI 函数的JNIEnv指针，以及一个jclass参数，用来指代定义该 native 方法的类，即Foo类。</p>
<p>两个实例 native 方法bar的第二个参数则是jobject类型的，用来指代该 native 方法的调用者，也就是Foo类的实例。</p>
<p>如果 native 方法声明了参数，那么对应的 C 函数将接收这些参数。在我们的例子中，第一个bar方法声明了 int 型和 long 型的参数，对应的 C 函数则接收 jint 和 jlong 类型的参数；第二个bar方法声明了 String 类型和 Object 类型的参数，对应的 C 函数则接收 jstring 和 jobject 类型的参数。</p>
<p>下面，我们继续修改上一小节中的foo.c，并在 C 代码中获取Foo类实例的i字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;org_example_Foo.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span></span><br><span class="line">  <span class="params">(JNIEnv *env, jobject thisObject, jstring str, jobject obj)</span> &#123;</span><br><span class="line">  jclass cls = (*env)-&gt;GetObjectClass(env, thisObject);</span><br><span class="line">  jfieldID fieldID = (*env)-&gt;GetFieldID(env, cls, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">  jint value = (*env)-&gt;GetIntField(env, thisObject, fieldID);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, World 0x%x\n&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在 JNI 中访问字段类似于反射 API：我们首先需要通过类实例获得FieldID，然后再通过FieldID获得某个实例中该字段的值。不过，与 Java 代码相比，上述代码貌似不用处理异常。事实果真如此吗？</p>
<p>下面我就尝试获取了不存在的字段j，运行结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ java org.example.Foo</span><br><span class="line">Hello, World 0x5</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.NoSuchFieldError: j</span><br><span class="line"> at org.example.Foo.bar(Native Method)</span><br><span class="line"> at org.example.Foo.main(Foo.java:20)</span><br></pre></td></tr></table></figure>

<p>我们可以看到，printf语句照常执行并打印出Hello, World 0x5，但这个数值明显是错误的。当从 C 函数返回至 main 方法时，Java 虚拟机又会抛出NoSuchFieldError异常。</p>
<p>实际上，当调用 JNI 函数时，Java 虚拟机便已生成异常实例，并缓存在内存中的某个位置。与 Java 编程不一样的是，它并不会显式地跳转至异常处理器或者调用者中，而是继续执行接下来的 C 代码。</p>
<p>因此，当从可能触发异常的 JNI 函数返回时，我们需要通过 JNI 函数ExceptionOccurred检查是否发生了异常，并且作出相应的处理。如果无须抛出该异常，那么我们需要通过 JNI 函数ExceptionClear显式地清空已缓存的异常。</p>
<p>具体示例如下所示（为了控制代码篇幅，我仅在第一个GetFieldID后检查异常以及清空异常）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include <span class="string">&quot;org_example_Foo.h&quot;</span></span><br><span class="line"> </span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span></span><br><span class="line">  <span class="params">(JNIEnv *env, jobject thisObject, jstring str, jobject obj)</span> &#123;</span><br><span class="line">  <span class="type">jclass</span> <span class="variable">cls</span> <span class="operator">=</span> (*env)-&gt;GetObjectClass(env, thisObject);</span><br><span class="line">  <span class="type">jfieldID</span> <span class="variable">fieldID</span> <span class="operator">=</span> (*env)-&gt;GetFieldID(env, cls, <span class="string">&quot;j&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*env)-&gt;ExceptionOccurred(env)) &#123;</span><br><span class="line">    printf(<span class="string">&quot;Exception!\n&quot;</span>);</span><br><span class="line">    (*env)-&gt;ExceptionClear(env);</span><br><span class="line">  &#125;</span><br><span class="line">  fieldID = (*env)-&gt;GetFieldID(env, cls, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">  <span class="type">jint</span> <span class="variable">value</span> <span class="operator">=</span> (*env)-&gt;GetIntField(env, thisObject, fieldID);</span><br><span class="line">  <span class="comment">// we should put an exception guard here as well.</span></span><br><span class="line">  printf(<span class="string">&quot;Hello, World 0x%x\n&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="局部引用与全局引用"><a href="#局部引用与全局引用" class="headerlink" title="局部引用与全局引用"></a>局部引用与全局引用</h1><p>在 C 代码中，我们可以访问所传入的引用类型参数，也可以通过 JNI 函数创建新的 Java 对象。</p>
<p>这些 Java 对象显然也会受到垃圾回收器的影响。因此，Java 虚拟机需要一种机制，来告知垃圾回收算法，不要回收这些 C 代码中可能引用到的 Java 对象。</p>
<p>这种机制便是 JNI 的局部引用（Local Reference）和全局引用（Global Reference）。垃圾回收算法会将被这两种引用指向的对象标记为不可回收。</p>
<p>事实上，无论是传入的引用类型参数，还是通过 JNI 函数（除NewGlobalRef及NewWeakGlobalRef之外）返回的引用类型对象，都属于局部引用。</p>
<p>不过，一旦从 C 函数中返回至 Java 方法之中，那么局部引用将失效。也就是说，垃圾回收器在标记垃圾时不再考虑这些局部引用。</p>
<p>这就意味着，我们不能缓存局部引用，以供另一 C 线程或下一次 native 方法调用时使用。</p>
<p>对于这种应用场景，我们需要借助 JNI 函数NewGlobalRef，将该局部引用转换为全局引用，以确保其指向的 Java 对象不会被垃圾回收。</p>
<p>相应的，我们还可以通过 JNI 函数DeleteGlobalRef来消除全局引用，以便回收被全局引用指向的 Java 对象。</p>
<p>此外，当 C 函数运行时间极其长时，我们也应该考虑通过 JNI 函数DeleteLocalRef，消除不再使用的局部引用，以便回收被引用的 Java 对象。</p>
<p>另一方面，由于垃圾回收器可能会移动对象在内存中的位置，因此 Java 虚拟机需要另一种机制，来保证局部引用或者全局引用将正确地指向移动过后的对象。</p>
<p>HotSpot 虚拟机是通过句柄（handle）来完成上述需求的。这里句柄指的是内存中 Java 对象的指针的指针。当发生垃圾回收时，如果 Java 对象被移动了，那么句柄指向的指针值也将发生变动，但句柄本身保持不变。</p>
<p>实际上，无论是局部引用还是全局引用，都是句柄。其中，局部引用所对应的句柄有两种存储方式，一是在本地方法栈帧中，主要用于存放 C 函数所接收的来自 Java 层面的引用类型参数；另一种则是线程私有的句柄块，主要用于存放 C 函数运行过程中创建的局部引用。</p>
<p>当从 C 函数返回至 Java 方法时，本地方法栈帧中的句柄将会被自动清除。而线程私有句柄块则需要由 Java 虚拟机显式清理。</p>
<p>进入 C 函数时对引用类型参数的句柄化，和调整参数位置（C 调用和 Java 调用传参的方式不一样），以及从 C 函数返回时清理线程私有句柄块，共同造就了 JNI 调用的额外性能开销（具体可参考该 stackoverflow 上的<a href="https://stackoverflow.com/questions/24746776/what-does-a-jvm-have-to-do-when-calling-a-native-method/24747484#24747484">回答</a>）。</p>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>今天我介绍了 JNI 的运行机制。</p>
<p>Java 中的 native 方法的链接方式主要有两种。一是按照 JNI 的默认规范命名所要链接的 C 函数，并依赖于 Java 虚拟机自动链接。另一种则是在 C 代码中主动链接。</p>
<p>JNI 提供了一系列 API 来允许 C 代码使用 Java 语言特性。这些 API 不仅使用了特殊的数据结构来表示 Java 类，还拥有特殊的异常处理模式。</p>
<p>JNI 中的引用可分为局部引用和全局引用。这两者都可以阻止垃圾回收器回收被引用的 Java 对象。不同的是，局部引用在 native 方法调用返回之后便会失效。传入参数以及大部分 JNI API 函数的返回值都属于局部引用。</p>
<p>今天的实践环节，请阅读<a href="https://www.ibm.com/developerworks/java/library/j-jni/index.html">该文档</a>中的 Performance pitfalls 以及 Correctness pitfalls 两节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-31/" class="post-title-link" itemprop="url">31 | Java虚拟机的监控及诊断工具（GUI篇）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 17:08:20" itemprop="dateCreated datePublished" datetime="2020-01-23T17:08:20+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-ImIYeAhH" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-ImIYeAhH"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频31",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/81/58/811ab21a45317b53c02d2a87a9371558.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们来继续了解 Java 虚拟机的监控及诊断工具。</p>
<h1 id="eclipse-MAT"><a href="#eclipse-MAT" class="headerlink" title="eclipse MAT"></a>eclipse MAT</h1><p>在上一篇中，我介绍了jmap工具，它支持导出 Java 虚拟机堆的二进制快照。eclipse 的MAT 工具便是其中一个能够解析这类二进制快照的工具。</p>
<p>MAT 本身也能够获取堆的二进制快照。该功能将借助jps列出当前正在运行的 Java 进程，以供选择并获取快照。由于jps会将自己列入其中，因此你会在列表中发现一个已经结束运行的jps进程。</p>
<p><img src="/images/2020/01/23/5bac98e0-3dbe-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>MAT 获取二进制快照的方式有三种，一是使用 Attach API，二是新建一个 Java 虚拟机来运行 Attach API，三是使用jmap工具。</p>
<p>这三种本质上都是在使用 Attach API。不过，在目标进程启用了DisableAttachMechanism参数时，前两者将不在选取列表中显示，后者将在运行时报错。</p>
<p>当加载完堆快照之后，MAT 的主界面将展示一张饼状图，其中列举占据的 Retained heap 最多的几个对象。</p>
<p><img src="/images/2020/01/23/625cf040-3dbe-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>这里讲一下 MAT 计算对象占据内存的<a href="https://help.eclipse.org/mars/topic/org.eclipse.mat.ui.help/concepts/shallowretainedheap.html?cp=46_2_1">两种方式</a>。第一种是 Shallow heap，指的是对象自身所占据的内存。第二种是 Retained heap，指的是当对象不再被引用时，垃圾回收器所能回收的总内存，包括对象自身所占据的内存，以及仅能够通过该对象引用到的其他对象所占据的内存。上面的饼状图便是基于 Retained heap 的。</p>
<p>MAT 包括了两个比较重要的视图，分别是直方图（histogram）和支配树（dominator tree）。</p>
<p><img src="/images/2020/01/23/7164e660-3dbe-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>MAT 的直方图和jmap的-histo子命令一样，都能够展示各个类的实例数目以及这些实例的 Shallow heap 总和。但是，MAT 的直方图还能够计算 Retained heap，并支持基于实例数目或 Retained heap 的排序方式（默认为 Shallow heap）。此外，MAT 还可以将直方图中的类按照超类、类加载器或者包名分组。</p>
<p>当选中某个类时，MAT 界面左上角的 Inspector 窗口将展示该类的 Class 实例的相关信息，如类加载器等。（下图中的ClassLoader @ 0x0指的便是启动类加载器。）</p>
<p><img src="/images/2020/01/23/77cbd8b0-3dbe-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>支配树的概念源自图论。在一则流图（flow diagram）中，如果从入口节点到 b 节点的所有路径都要经过 a 节点，那么 a 支配（dominate）b。</p>
<p>在 a 支配 b，且 a 不同于 b 的情况下（即 a 严格支配 b），如果从 a 节点到 b 节点的所有路径中不存在支配 b 的其他节点，那么 a 直接支配（immediate dominate）b。这里的支配树指的便是由节点的直接支配节点所组成的树状结构。</p>
<p>我们可以将堆中所有的对象看成一张对象图，每个对象是一个图节点，而 GC Roots 则是对象图的入口，对象之间的引用关系则构成了对象图中的有向边。这样一来，我们便能够构造出该对象图所对应的支配树。</p>
<p>MAT 将按照每个对象 Retained heap 的大小排列该支配树。如下图所示：</p>
<p><img src="/images/2020/01/23/7e431eb0-3dbe-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>根据 Retained heap 的定义，只要能够回收上图右侧的表中的第一个对象，那么垃圾回收器便能够释放出 13.6MB 内存。</p>
<p>需要注意的是，对象的引用型字段未必对应支配树中的父子节点关系。假设对象 a 拥有两个引用型字段，分别指向 b 和 c。而 b 和 c 各自拥有一个引用型字段，但都指向 d。如果没有其他引用指向 b、c 或 d，那么 a 直接支配 b、c 和 d，而 b（或 c）和 d 之间不存在支配关系。</p>
<p>当在支配树视图中选中某一对象时，我们还可以通过 Path To GC Roots 功能，反向列出该对象到 GC Roots 的引用路径。如下图所示：</p>
<p><img src="/images/2020/01/23/84a68e90-3dbe-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>MAT 还将自动匹配内存泄漏中的常见模式，并汇报潜在的内存泄漏问题。具体可参考该帮助文档以及<a href="http://memoryanalyzer.blogspot.com/2008/05/automated-heap-dump-analysis-finding.html">这篇博客</a>。</p>
<h1 id="Java-Mission-Control"><a href="#Java-Mission-Control" class="headerlink" title="Java Mission Control"></a>Java Mission Control</h1><blockquote>
<p>注意：自 Java 11 开始，本节介绍的 JFR 已经开源。但在之前的 Java 版本，JFR 属于 Commercial Feature，需要通过 Java 虚拟机参数-XX:+UnlockCommercialFeatures开启。</p>
</blockquote>
<blockquote>
<p>我个人不清楚也不能回答关于 Java 11 之前的版本是否仍需要商务许可（Commercial License）的问题。请另行咨询后再使用，或者直接使用 Java 11。</p>
</blockquote>
<blockquote>
<p>Java Mission Control（JMC）是 Java 虚拟机平台上的性能监控工具。它包含一个 GUI 客户端，以及众多用来收集 Java 虚拟机性能数据的插件，如 JMX Console（能够访问用来存放虚拟机各个子系统运行数据的MXBeans），以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p>
</blockquote>
<p>JFR 的性能开销很小，在默认配置下平均低于 1%。与其他工具相比，JFR 能够直接访问虚拟机内的数据，并且不会影响虚拟机的优化。因此，它非常适用于生产环境下满负荷运行的 Java 程序。</p>
<p>当启用时，JFR 将记录运行过程中发生的一系列事件。其中包括 Java 层面的事件，如线程事件、锁事件，以及 Java 虚拟机内部的事件，如新建对象、垃圾回收和即时编译事件。</p>
<p>按照发生时机以及持续时间来划分，JFR 的事件共有四种类型，它们分别为以下四种。</p>
<ol>
<li>瞬时事件（Instant Event），用户关心的是它们发生与否，例如异常、线程启动事件。</li>
<li>持续事件（Duration Event），用户关心的是它们的持续时间，例如垃圾回收事件。</li>
<li>计时事件（Timed Event），是时长超出指定阈值的持续事件。</li>
<li>取样事件（Sample Event），是周期性取样的事件。</li>
<li>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时间统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法。</li>
</ol>
<p>JFR 的取样事件要比其他工具更加精确。以方法抽样为例，其他工具通常基于 JVMTI（<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">Java Virtual Machine Tool Interface</a>）的GetAllStackTraces API。该 API 依赖于安全点机制，其获得的栈轨迹总是在安全点上，由此得出的结论未必精确。JFR 则不然，它不依赖于安全点机制，因此其结果相对来说更加精确。</p>
<p>JFR 的启用方式主要有三种。</p>
<p>第一种是在运行目标 Java 程序时添加-XX:StartFlightRecording&#x3D;参数。关于该参数的配置详情，你可以参考<a href="https://docs.oracle.com/en/java/javase/11/tools/java.html">该帮助文档</a>（请在页面中搜索StartFlightRecording）。</p>
<p>下面我列举三种常见的配置方式。</p>
<ul>
<li>在下面这条命令中，JFR 将会在 Java 虚拟机启动 5s 后（对应delay&#x3D;5s）收集数据，持续 20s（对应duration&#x3D;20s）。当收集完毕后，JFR 会将收集得到的数据保存至指定的文件中（对应filename&#x3D;myrecording.jfr）。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time fixed</span></span><br><span class="line">$ java -XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecording.jfr,settings=profile MyApp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>settings&#x3D;profile指定了 JFR 所收集的事件类型。默认情况下，JFR 将加载配置文件$JDK&#x2F;lib&#x2F;jfr&#x2F;default.jfc，并识别其中所包含的事件类型。当使用了settings&#x3D;profile配置时，JFR 将加载配置文件$JDK&#x2F;lib&#x2F;jfr&#x2F;profile.jfc。该配置文件所包含的事件类型要多于默认的default.jfc，因此性能开销也要大一些（约为 2%）。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>default.jfc以及profile.jfc均为 XML 文件。后面我会介绍如何利用 JMC 来进行修改。</p>
</blockquote>
<ul>
<li><p>在下面这条命令中，JFR 将在 Java 虚拟机启动之后持续收集数据，直至进程退出。在进程退出时（对应dumponexit&#x3D;true），JFR 会将收集得到的数据保存至指定的文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Continuous, dump on exit</span></span><br><span class="line">$ java -XX:StartFlightRecording=dumponexit=<span class="literal">true</span>,filename=myrecording.jfr MyApp</span><br></pre></td></tr></table></figure>
</li>
<li><p>在下面这条命令中，JFR 将在 Java 虚拟机启动之后持续收集数据，直至进程退出。该命令不会主动保存 JFR 收集得到的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Continuous, dump on demand</span><br><span class="line">$ java -XX:StartFlightRecording=maxage=10m,maxsize=100m,name=SomeLabel MyApp</span><br><span class="line">Started recording <span class="number">1.</span></span><br><span class="line"> </span><br><span class="line">Use jcmd <span class="number">38502</span> JFR.dump name=SomeLabel filename=FILEPATH to copy recording data to file.</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<p>由于 JFR 将持续收集数据，如果不加以限制，那么 JFR 可能会填满硬盘的所有空间。因此，我们有必要对这种模式下所收集的数据进行限制。</p>
<p>在这条命令中，maxage&#x3D;10m指的是仅保留 10 分钟以内的事件，maxsize&#x3D;100m指的是仅保留 100MB 以内的事件。一旦所收集的事件达到其中任意一个限制，JFR 便会开始清除不合规格的事件。</p>
<p>然而，为了保持较小的性能开销，JFR 并不会频繁地校验这两个限制。因此，在实践过程中你往往会发现指定文件的大小超出限制，或者文件中所存储事件的时间超出限制。具体解释请参考<a href="https://community.oracle.com/thread/3514679">这篇帖子</a>。</p>
<p>前面提到，该命令不会主动保存 JFR 收集得到的数据。用户需要运行jcmd <PID> JFR.dump命令方能保存。</p>
<p>这便是 JFR 的第二种启用方式，即通过jcmd来让 JFR 开始收集数据、停止收集数据，或者保存所收集的数据，对应的子命令分别为JFR.start，JFR.stop，以及JFR.dump。</p>
<p>JFR.start子命令所接收的配置及格式和-XX:StartFlightRecording&#x3D;参数的类似。这些配置包括delay、duration、settings、maxage、maxsize以及name。前几个参数我们都已经介绍过了，最后一个参数name就是一个标签，当同一进程中存在多个 JFR 数据收集操作时，我们可以通过该标签来辨别。</p>
<p>在启动目标进程时，我们不再添加-XX:StartFlightRecording&#x3D;参数。在目标进程运行过程中，我们可以运行JFR.start子命令远程启用目标进程的 JFR 功能。具体用法如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd &lt;PID&gt; JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel</span><br></pre></td></tr></table></figure>

<p>上述命令运行过后，目标进程中的 JFR 已经开始收集数据。此时，我们可以通过下述命令来导出已经收集到的数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd &lt;PID&gt; JFR.dump name=SomeLabel filename=myrecording.jfr</span><br></pre></td></tr></table></figure>

<p>最后，我们可以通过下述命令关闭目标进程中的 JFR：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd &lt;PID&gt; JFR.stop name=SomeLabel</span><br></pre></td></tr></table></figure>

<p>关于JFR.start、JFR.dump和JFR.stop的其他用法，你可以参考该<a href="https://docs.oracle.com/javacomponents/jmc-5-5/jfr-runtime-guide/comline.htm#JFRRT185">帮助文档</a>。</p>
<p>第三种启用 JFR 的方式则是 JMC 中的 JFR 插件。</p>
<p><img src="/images/2020/01/23/864220b0-3dbf-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>在 JMC GUI 客户端左侧的 JVM 浏览器中，我们可以看到所有正在运行的 Java 程序。当点击右键弹出菜单中的Start Flight Recording…时，JMC 便会弹出另一个窗口，用来配置 JFR 的启动参数，如下图所示：</p>
<p><img src="/images/2020/01/23/8bd03f30-3dbf-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>这里的配置参数与前两种启动 JFR 的方式并无二致，同样也包括标签名、收集数据的持续时间、缓存事件的时间及空间限制，以及配置所要监控事件的Event settings。<br>（这里对应前两种启动方式的settings&#x3D;default|profile）</p>
<blockquote>
<p>JMC 提供了两个选择：Continuous 和 Profiling，分别对应$JDK&#x2F;lib&#x2F;jfr&#x2F;里的default.jfc和profile.jfc。</p>
</blockquote>
<p>我们可以通过 JMC 的Flight Recording Template Manager导入这些 jfc 文件，并在 GUI 界面上进行更改。更改完毕后，我们可以导出为新的 jfc 文件，以便在服务器端使用。</p>
<p>当收集完成时，JMC 会自动打开所生成的 jfr 文件，并在主界面中列举目标进程在收集数据的这段时间内的潜在问题。例如，Parallel Threads一节，便汇报了没有完整利用 CPU 资源的问题。</p>
<p><img src="/images/2020/01/23/99370870-3dbf-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>客户端的左边则罗列了 Java 虚拟机的各个子系统。JMC 将根据 JFR 所收集到的每个子系统的事件来进行可视化，转换成图或者表。</p>
<p><img src="/images/2020/01/23/9f221400-3dbf-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>这里我简单地介绍其中两个。</p>
<p>垃圾回收子系统所对应的选项卡展示了 JFR 所收集到的 GC 事件，以及基于这些 GC 事件的数据生成的堆已用空间的分布图，Metaspace 大小的分布图，最长暂停以及总暂停的直方分布图。</p>
<p><img src="/images/2020/01/23/a5d48e40-3dbf-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>即时编译子系统所对应的选项卡则展示了方法编译时间的直方图，以及按编译时间排序的编译任务表。</p>
<p>后者可能出现同方法名同方法描述符的编译任务。其原因主要有两个，一是不同编译层次的即时编译，如 3 层的 C1 编译以及 4 层的 C2 编译。二是去优化后的重新编译。</p>
<p><img src="/images/2020/01/23/ac31bc90-3dbf-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>JMC 的图表总体而言都不难理解。你可以逐个探索，我在这里便不详细展开了。</p>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>今天我介绍了两个 GUI 工具：eclipse MAT 以及 JMC。</p>
<p>eclipse MAT 可用于分析由jmap命令导出的 Java 堆快照。它包括两个相对比较重要的视图，分别为直方图和支配树。直方图展示了各个类的实例数目以及这些实例的 Shallow heap 或 Retained heap 的总和。支配树则展示了快照中每个对象所直接支配的对象。</p>
<p>Java Mission Control 是 Java 虚拟机平台上的性能监控工具。Java Flight Recorder 是 JMC 的其中一个组件，能够以极低的性能开销收集 Java 虚拟机的性能数据。</p>
<p>JFR 的启用方式有三种，分别为在命令行中使用-XX:StartFlightRecording&#x3D;参数，使用jcmd的JFR.*子命令，以及 JMC 的 JFR 插件。JMC 能够加载 JFR 的输出结果，并且生成各种信息丰富的图表。</p>
<p>今天的实践环节，请你试用 JMC 中的 MBean Server 功能，并通过 JMC 的帮助文档（Help-&gt;Java Mission Control Help），以及<a href="https://docs.oracle.com/javase/tutorial/jmx/mbeans/index.html">该教程</a>来了解该功能的具体含义。</p>
<p><img src="/images/2020/01/23/c391edb0-3dbf-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>由于篇幅的限制，我就不再介绍<a href="https://visualvm.github.io/index.html">VisualVM</a> 以及<a href="https://github.com/AdoptOpenJDK/jitwatch">JITWatch</a> 了。感兴趣的同学可自行下载研究。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-30/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-30/" class="post-title-link" itemprop="url">30 | Java虚拟机的监控及诊断工具（命令行篇）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 16:56:11" itemprop="dateCreated datePublished" datetime="2020-01-23T16:56:11+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-MVLaCJAm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-MVLaCJAm"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频30",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/43/ca/43dd5d504bd989b429810514b702e4ca.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天，我们来一起了解一下 JDK 中用于监控及诊断工具。本篇中我将使用刚刚发布的 Java 11 版本的工具进行示范。</p>
<p>#jps<br>你可能用过ps命令，打印所有正在运行的进程的相关信息。JDK 中的jps命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jps.html">帮助文档</a>）沿用了同样的概念：它将打印所有正在运行的 Java 进程的相关信息。</p>
<p>在默认情况下，jps的输出信息包括 Java 进程的进程 ID 以及主类名。我们还可以通过追加参数，来打印额外的信息。例如，-l将打印模块名以及包名；-v将打印传递给 Java 虚拟机的参数（如-XX:+UnlockExperimentalVMOptions -XX:+UseZGC）；-m将打印传递给主类的参数。</p>
<p>具体的示例如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jps -mlv</span><br><span class="line">18331 org.example.Foo Hello World</span><br><span class="line">18332 jdk.jcmd/sun.tools.jps.Jps -mlv -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home -Xms8m -Djdk.module.main=jdk.jcmd</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果某 Java 进程关闭了默认开启的UsePerfData参数（即使用参数-XX:-UsePerfData），那么jps命令（以及下面介绍的jstat）将无法探知该 Java 进程。</p>
<p>当获得 Java 进程的进程 ID 之后，我们便可以调用接下来介绍的各项监控及诊断工具了。</p>
<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>jstat命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html">帮助文档</a>）可用来打印目标 Java 进程的性能数据。它包括多条子命令，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -options</span><br><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure>

<p>在这些子命令中，-class将打印类加载相关的数据，-compiler和-printcompilation将打印即时编译相关的数据。剩下的都是以-gc为前缀的子命令，它们将打印垃圾回收相关的数据。</p>
<p>默认情况下，jstat只会打印一次性能数据。我们可以将它配置为每隔一段时间打印一次，直至目标 Java 进程终止，或者达到我们所配置的最大打印次数。具体示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Usage: jstat -outputOptions [-t] [-hlines] VMID [interval [count]]</span><br><span class="line">$ jstat -gc <span class="number">22126</span> 1s <span class="number">4</span></span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line"><span class="number">17472</span>,<span class="number">0</span> <span class="number">17472</span>,<span class="number">0</span>  <span class="number">0</span>,<span class="number">0</span>    <span class="number">0</span>,<span class="number">0</span>   <span class="number">139904</span>,<span class="number">0</span> <span class="number">47146</span>,<span class="number">4</span>   <span class="number">349568</span>,<span class="number">0</span>   <span class="number">21321</span>,<span class="number">0</span>   <span class="number">30020</span>,<span class="number">0</span> <span class="number">28001</span>,<span class="number">8</span> <span class="number">4864</span>,<span class="number">0</span> <span class="number">4673</span>,<span class="number">4</span>     <span class="number">22</span>    <span class="number">0</span>,080   <span class="number">3</span>      <span class="number">0</span>,<span class="number">270</span>   <span class="number">0</span>      <span class="number">0</span>,<span class="number">000</span>    <span class="number">0</span>,<span class="number">350</span></span><br><span class="line"><span class="number">17472</span>,<span class="number">0</span> <span class="number">17472</span>,<span class="number">0</span> <span class="number">420</span>,<span class="number">6</span>   <span class="number">0</span>,<span class="number">0</span>   <span class="number">139904</span>,<span class="number">0</span> <span class="number">11178</span>,<span class="number">4</span>   <span class="number">349568</span>,<span class="number">0</span>   <span class="number">21321</span>,<span class="number">0</span>   <span class="number">30020</span>,<span class="number">0</span> <span class="number">28090</span>,<span class="number">1</span> <span class="number">4864</span>,<span class="number">0</span> <span class="number">4674</span>,<span class="number">2</span>     <span class="number">28</span>    <span class="number">0</span>,084   <span class="number">3</span>      <span class="number">0</span>,<span class="number">270</span>   <span class="number">0</span>      <span class="number">0</span>,<span class="number">000</span>    <span class="number">0</span>,<span class="number">354</span></span><br><span class="line"><span class="number">17472</span>,<span class="number">0</span> <span class="number">17472</span>,<span class="number">0</span>  <span class="number">0</span>,<span class="number">0</span>   <span class="number">403</span>,<span class="number">9</span>  <span class="number">139904</span>,<span class="number">0</span> <span class="number">139538</span>,<span class="number">4</span>  <span class="number">349568</span>,<span class="number">0</span>   <span class="number">21323</span>,<span class="number">4</span>   <span class="number">30020</span>,<span class="number">0</span> <span class="number">28137</span>,<span class="number">2</span> <span class="number">4864</span>,<span class="number">0</span> <span class="number">4674</span>,<span class="number">2</span>     <span class="number">34</span>    <span class="number">0</span>,088   <span class="number">4</span>      <span class="number">0</span>,<span class="number">359</span>   <span class="number">0</span>      <span class="number">0</span>,<span class="number">000</span>    <span class="number">0</span>,<span class="number">446</span></span><br><span class="line"><span class="number">17472</span>,<span class="number">0</span> <span class="number">17472</span>,<span class="number">0</span>  <span class="number">0</span>,<span class="number">0</span>    <span class="number">0</span>,<span class="number">0</span>   <span class="number">139904</span>,<span class="number">0</span>   <span class="number">0</span>,<span class="number">0</span>     <span class="number">349568</span>,<span class="number">0</span>   <span class="number">21326</span>,<span class="number">1</span>   <span class="number">30020</span>,<span class="number">0</span> <span class="number">28093</span>,<span class="number">6</span> <span class="number">4864</span>,<span class="number">0</span> <span class="number">4673</span>,<span class="number">4</span>     <span class="number">38</span>    <span class="number">0</span>,091   <span class="number">5</span>      <span class="number">0</span>,<span class="number">445</span>   <span class="number">0</span>      <span class="number">0</span>,<span class="number">000</span>    <span class="number">0</span>,<span class="number">536</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当监控本地环境的 Java 进程时，VMID 可以简单理解为 PID。如果需要监控远程环境的 Java 进程，你可以参考 jstat 的帮助文档。</p>
</blockquote>
<p>在上面这个示例中，22126 进程是一个使用了 CMS 垃圾回收器的 Java 进程。我们利用jstat的-gc子命令，来打印该进程垃圾回收相关的数据。命令最后的1s 4表示每隔 1 秒打印一次，共打印 4 次。</p>
<p>在-gc子命令的输出中，前四列分别为两个 Survivor 区的容量（Capacity）和已使用量（Utility）。我们可以看到，这两个 Survivor 区的容量相等，而且始终有一个 Survivor 区的内存使用量为 0。</p>
<p>当使用默认的 G1 GC 时，输出结果则有另一些特征：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc <span class="number">22208</span> 1s</span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>   <span class="number">16384</span>,<span class="number">0</span>  <span class="number">0</span>,<span class="number">0</span>   <span class="number">16384</span>,<span class="number">0</span> <span class="number">210944</span>,<span class="number">0</span> <span class="number">192512</span>,<span class="number">0</span>  <span class="number">133120</span>,<span class="number">0</span>    <span class="number">5332</span>,<span class="number">5</span>   <span class="number">28848</span>,<span class="number">0</span> <span class="number">26886</span>,<span class="number">4</span> <span class="number">4864</span>,<span class="number">0</span> <span class="number">4620</span>,<span class="number">5</span>     <span class="number">19</span>    <span class="number">0</span>,<span class="number">067</span>   <span class="number">1</span>      <span class="number">0</span>,<span class="number">016</span>   <span class="number">2</span>      <span class="number">0</span>,<span class="number">002</span>    <span class="number">0</span>,084</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>   <span class="number">16384</span>,<span class="number">0</span>  <span class="number">0</span>,<span class="number">0</span>   <span class="number">16384</span>,<span class="number">0</span> <span class="number">210944</span>,<span class="number">0</span> <span class="number">83968</span>,<span class="number">0</span>   <span class="number">133120</span>,<span class="number">0</span>    <span class="number">5749</span>,<span class="number">9</span>   <span class="number">29104</span>,<span class="number">0</span> <span class="number">27132</span>,<span class="number">8</span> <span class="number">4864</span>,<span class="number">0</span> <span class="number">4621</span>,<span class="number">0</span>     <span class="number">21</span>    <span class="number">0</span>,078   <span class="number">1</span>      <span class="number">0</span>,<span class="number">016</span>   <span class="number">2</span>      <span class="number">0</span>,<span class="number">002</span>    <span class="number">0</span>,095</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>    <span class="number">0</span>,<span class="number">0</span>    <span class="number">0</span>,<span class="number">0</span>    <span class="number">0</span>,<span class="number">0</span>   <span class="number">71680</span>,<span class="number">0</span>  <span class="number">18432</span>,<span class="number">0</span>   <span class="number">45056</span>,<span class="number">0</span>    <span class="number">20285</span>,<span class="number">1</span>   <span class="number">29872</span>,<span class="number">0</span> <span class="number">27952</span>,<span class="number">4</span> <span class="number">4864</span>,<span class="number">0</span> <span class="number">4671</span>,<span class="number">6</span>     <span class="number">23</span>    <span class="number">0</span>,089   <span class="number">2</span>      <span class="number">0</span>,<span class="number">063</span>   <span class="number">2</span>      <span class="number">0</span>,<span class="number">002</span>    <span class="number">0</span>,<span class="number">153</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>   <span class="number">2048</span>,<span class="number">0</span>  <span class="number">0</span>,<span class="number">0</span>   <span class="number">2048</span>,<span class="number">0</span> <span class="number">69632</span>,<span class="number">0</span>  <span class="number">28672</span>,<span class="number">0</span>   <span class="number">45056</span>,<span class="number">0</span>    <span class="number">18608</span>,<span class="number">1</span>   <span class="number">30128</span>,<span class="number">0</span> <span class="number">28030</span>,<span class="number">4</span> <span class="number">4864</span>,<span class="number">0</span> <span class="number">4672</span>,<span class="number">4</span>     <span class="number">32</span>    <span class="number">0</span>,093   <span class="number">2</span>      <span class="number">0</span>,<span class="number">063</span>   <span class="number">2</span>      <span class="number">0</span>,<span class="number">002</span>    <span class="number">0</span>,<span class="number">158</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在上面这个示例中，jstat每隔 1s 便会打印垃圾回收的信息，并且不断重复下去。</p>
<p>你可能已经留意到，S0C和S0U始终为 0，而且另一个 Survivor 区的容量（S1C）可能会下降至 0。</p>
<p>这是因为，当使用 G1 GC 时，Java 虚拟机不再设置 Eden 区、Survivor 区，老年代区的内存边界，而是将堆划分为若干个等长内存区域。</p>
<p>每个内存区域都可以作为 Eden 区、Survivor 区以及老年代区中的任一种，并且可以在不同区域类型之间来回切换。（参考链接）</p>
<p>换句话说，逻辑上我们只有一个 Survivor 区。当需要迁移 Survivor 区中的数据时（即 Copying GC），我们只需另外申请一个或多个内存区域，作为新的 Survivor 区。</p>
<p>因此，Java 虚拟机决定在使用 G1 GC 时，将所有 Survivor 内存区域的总容量以及已使用量存放至 S1C 和 S1U 中，而 S0C 和 S0U 则被设置为 0。</p>
<p>当发生垃圾回收时，Java 虚拟机可能出现 Survivor 内存区域内的对象全被回收或晋升的现象。</p>
<p>在这种情况下，Java 虚拟机会将这块内存区域回收，并标记为可分配的状态。这样子做的结果是，堆中可能完全没有 Survivor 内存区域，因而相应的 S1C 和 S1U 将会是 0。</p>
<p>jstat还有一个非常有用的参数-t，它将在每行数据之前打印目标 Java 进程的启动时间。例如，在下面这个示例中，第一列代表该 Java 进程已经启动了 10.7 秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc -t <span class="number">22407</span></span><br><span class="line">Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line">           <span class="number">10</span>,<span class="number">7</span>  <span class="number">0</span>,<span class="number">0</span>    <span class="number">0</span>,<span class="number">0</span>    <span class="number">0</span>,<span class="number">0</span>    <span class="number">0</span>,<span class="number">0</span>   <span class="number">55296</span>,<span class="number">0</span>  <span class="number">45056</span>,<span class="number">0</span>   <span class="number">34816</span>,<span class="number">0</span>    <span class="number">20267</span>,<span class="number">8</span>   <span class="number">30128</span>,<span class="number">0</span> <span class="number">27975</span>,<span class="number">3</span> <span class="number">4864</span>,<span class="number">0</span> <span class="number">4671</span>,<span class="number">6</span>     <span class="number">33</span>    <span class="number">0</span>,086   <span class="number">3</span>      <span class="number">0</span>,<span class="number">111</span>   <span class="number">2</span>      <span class="number">0</span>,<span class="number">001</span>    <span class="number">0</span>,<span class="number">198</span></span><br></pre></td></tr></table></figure>

<p>我们可以比较 Java 进程的启动时间以及总 GC 时间（GCT 列），或者两次测量的间隔时间以及总 GC 时间的增量，来得出 GC 时间占运行时间的比例。</p>
<p>如果该比例超过 20%，则说明目前堆的压力较大；如果该比例超过 90%，则说明堆里几乎没有可用空间，随时都可能抛出 OOM 异常。</p>
<p>jstat还可以用来判断是否出现内存泄漏。在长时间运行的 Java 程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</p>
<p>然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p>
<blockquote>
<p>上面没有涉及的列（或者其他子命令的输出），你可以查阅帮助文档了解具体含义。至于文档中漏掉的 CGC 和 CGCT，它们分别代表并发 GC Stop-The-World 的次数和时间。</p>
</blockquote>
<h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>在这种情况下，我们便可以请jmap命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">帮助文档</a>）出马，分析 Java 虚拟机堆中的对象。</p>
<p>jmap同样包括多条子命令。</p>
<ol>
<li>-clstats，该子命令将打印被加载类的信息。</li>
<li>-finalizerinfo，该子命令将打印所有待 finalize 的对象。</li>
<li>-histo，该子命令将统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。此外，-histo:live只统计堆中的存活对象。</li>
<li>-dump，该子命令将导出 Java 虚拟机堆的快照。同样，-dump:live只保存堆中的存活对象。</li>
</ol>
<p>我们通常会利用jmap -dump:live,format&#x3D;b,file&#x3D;filename.bin命令，将堆中所有存活对象导出至一个文件之中。</p>
<p>这里format&#x3D;b将使jmap导出与hprof（在 Java 9 中已被移除）、-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError格式一致的文件。这种格式的文件可以被其他 GUI 工具查看，具体我会在下一篇中进行演示。</p>
<p>下面我贴了一段-histo子命令的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -histo 22574</span><br><span class="line"> num     <span class="comment">#instances         #bytes  class name (module)</span></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">   1:        500004       20000160  org.python.core.PyComplex</span><br><span class="line">   2:        570866       18267712  org.python.core.PyFloat</span><br><span class="line">   3:        360295       18027024  [B (java.base@11)</span><br><span class="line">   4:        339394       11429680  [Lorg.python.core.PyObject;</span><br><span class="line">   5:        308637       11194264  [Ljava.lang.Object; (java.base@11)</span><br><span class="line">   6:        301378        9291664  [I (java.base@11)</span><br><span class="line">   7:        225103        9004120  java.math.BigInteger (java.base@11)</span><br><span class="line">   8:        507362        8117792  org.python.core.PySequence<span class="variable">$1</span></span><br><span class="line">   9:        285009        6840216  org.python.core.PyLong</span><br><span class="line">  10:        282908        6789792  java.lang.String (java.base@11)</span><br><span class="line">  ...</span><br><span class="line">2281:             1             16  traceback<span class="variable">$py</span></span><br><span class="line">2282:             1             16  unicodedata<span class="variable">$py</span></span><br><span class="line">Total       5151277      167944400</span><br></pre></td></tr></table></figure>

<p>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。</p>
<p>也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live选项将无法探知到这些对象。</p>
<p>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。上一小节的jstat则不同。这是因为垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。</p>
<p>关于这种长时间等待的情况，你可以通过下面这段程序来复现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停时间较长，约为二三十秒，可酌情调整。</span></span><br><span class="line"><span class="comment">// CTRL+C 的 SIGINT 信号无法停止，需要 SIGKILL。</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">0x77777777</span>; i++) &#123; <span class="comment">// counted loop</span></span><br><span class="line">    sum += Math.log(i); <span class="comment">// Math.log is an intrinsic</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jmap（以及接下来的jinfo、jstack和jcmd）依赖于 Java 虚拟机的<a href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.attach/com/sun/tools/attach/package-summary.html">Attach API</a>，因此只能监控本地 Java 进程。</p>
<p>一旦开启 Java 虚拟机参数DisableAttachMechanism（即使用参数-XX:+DisableAttachMechanism），基于 Attach API 的命令将无法执行。反过来说，如果你不想被其他进程监控，那么你需要开启该参数。</p>
<h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><p>jinfo命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html">帮助文档</a>）可用来查看目标 Java 进程的参数，如传递给 Java 虚拟机的-X（即输出中的 jvm_args）、-XX参数（即输出中的 VM Flags），以及可在 Java 层面通过System.getProperty获取的-D参数（即输出中的 System Properties）。</p>
<p>具体的示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo <span class="number">31185</span></span><br><span class="line">Java System Properties:</span><br><span class="line"> </span><br><span class="line">gopherProxySet=<span class="literal">false</span></span><br><span class="line">awt.toolkit=sun.lwawt.macosx.LWCToolkit</span><br><span class="line">java.specification.version=<span class="number">11</span></span><br><span class="line">sun.cpu.isalist=</span><br><span class="line">sun.jnu.encoding=UTF-<span class="number">8</span></span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=<span class="number">4</span> -XX:ConcGCThreads=<span class="number">3</span> -XX:G1ConcRefinementThreads=<span class="number">10</span> -XX:G1HeapRegionSize=<span class="number">2097152</span> -XX:GCDrainStackTargetSize=<span class="number">64</span> -XX:InitialHeapSize=<span class="number">536870912</span> -XX:MarkStackSize=<span class="number">4194304</span> -XX:MaxHeapSize=<span class="number">8589934592</span> -XX:MaxNewSize=<span class="number">5152702464</span> -XX:MinHeapDeltaBytes=<span class="number">2097152</span> -XX:NonNMethodCodeHeapSize=<span class="number">5835340</span> -XX:NonProfiledCodeHeapSize=<span class="number">122911450</span> -XX:ProfiledCodeHeapSize=<span class="number">122911450</span> -XX:ReservedCodeCacheSize=<span class="number">251658240</span> -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class="line"> </span><br><span class="line">VM Arguments:</span><br><span class="line">jvm_args: -Xlog:gc -Xmx1024m</span><br><span class="line">java_command: org.example.Foo</span><br><span class="line"><span class="title function_">java_class_path</span> <span class="params">(initial)</span>: .</span><br><span class="line">Launcher Type: SUN_STANDARD</span><br></pre></td></tr></table></figure>

<p>jinfo还可以用来修改目标 Java 进程的“manageable”虚拟机参数。</p>
<p>举个例子，我们可以使用jinfo -flag +HeapDumpAfterFullGC <PID>命令，开启<PID>所指定的 Java 进程的HeapDumpAfterFullGC参数。</p>
<p>你可以通过下述命令查看其他 “manageable” 虚拟机参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+PrintFlagsFinal -version | grep manageable   </span><br><span class="line">     intx CMSAbortablePrecleanWaitMillis           = 100                                    &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSTriggerInterval                       = -1                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSWaitDuration                          = 2000                                   &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpAfterFullGC                      = <span class="literal">false</span>                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpBeforeFullGC                     = <span class="literal">false</span>                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpOnOutOfMemoryError               = <span class="literal">false</span>                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    ccstr HeapDumpPath                             =                                        &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MaxHeapFreeRatio                         = 70                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MinHeapFreeRatio                         = 40                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintClassHistogram                      = <span class="literal">false</span>                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintConcurrentLocks                     = <span class="literal">false</span>                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">java version <span class="string">&quot;11&quot;</span> 2018-09-25</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11+28)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)</span><br></pre></td></tr></table></figure>

<h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>jstack命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html">帮助文档</a>）可以用来打印目标 Java 进程中各个线程的栈轨迹，以及这些线程所持有的锁。</p>
<p>jstack的其中一个应用场景便是死锁检测。这里我用jstack获取一个已经死锁了的 Java 程序的栈信息。具体输出如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ jstack 31634</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span> <span class="comment">#12 prio=5 os_prio=31 cpu=1.32ms elapsed=34.24s tid=0x00007fb08601c800 nid=0x5d03 waiting for monitor entry  [0x000070000bc7e000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"> at DeadLock.foo(DeadLock.java:18)</span><br><span class="line"> - waiting to lock &lt;0x000000061ff904c0&gt; (a java.lang.Object)</span><br><span class="line"> - locked &lt;0x000000061ff904b0&gt; (a java.lang.Object)</span><br><span class="line"> at DeadLock$$Lambda<span class="variable">$1</span>/0x0000000800060840.run(Unknown Source)</span><br><span class="line"> at java.lang.Thread.run(java.base@11/Thread.java:834)</span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#13 prio=5 os_prio=31 cpu=1.43ms elapsed=34.24s tid=0x00007fb08601f800 nid=0x5f03 waiting for monitor entry  [0x000070000bd81000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"> at DeadLock.bar(DeadLock.java:33)</span><br><span class="line"> - waiting to lock &lt;0x000000061ff904b0&gt; (a java.lang.Object)</span><br><span class="line"> - locked &lt;0x000000061ff904c0&gt; (a java.lang.Object)</span><br><span class="line"> at DeadLock$$Lambda<span class="variable">$2</span>/0x0000000800063040.run(Unknown Source)</span><br><span class="line"> at java.lang.Thread.run(java.base@11/Thread.java:834)</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">JNI global refs: 6, weak refs: 0</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">  waiting to lock monitor 0x00007fb083015900 (object 0x000000061ff904c0, a java.lang.Object),</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">  waiting to lock monitor 0x00007fb083015800 (object 0x000000061ff904b0, a java.lang.Object),</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"> </span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line"> at DeadLock.foo(DeadLock.java:18)</span><br><span class="line"> - waiting to lock &lt;0x000000061ff904c0&gt; (a java.lang.Object)</span><br><span class="line"> - locked &lt;0x000000061ff904b0&gt; (a java.lang.Object)</span><br><span class="line"> at DeadLock$$Lambda<span class="variable">$1</span>/0x0000000800060840.run(Unknown Source)</span><br><span class="line"> at java.lang.Thread.run(java.base@11/Thread.java:834)</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line"> at DeadLock.bar(DeadLock.java:33)</span><br><span class="line"> - waiting to lock &lt;0x000000061ff904b0&gt; (a java.lang.Object)</span><br><span class="line"> - locked &lt;0x000000061ff904c0&gt; (a java.lang.Object)</span><br><span class="line"> at DeadLock$$Lambda<span class="variable">$2</span>/0x0000000800063040.run(Unknown Source)</span><br><span class="line"> at java.lang.Thread.run(java.base@11/Thread.java:834)</span><br><span class="line"> </span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>我们可以看到，jstack不仅会打印线程的栈轨迹、线程状态（BLOCKED）、持有的锁（locked …）以及正在请求的锁（waiting to lock …），而且还会分析出具体的死锁。</p>
<h1 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h1><p>你还可以直接使用jcmd命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">帮助文档</a>），来替代前面除了jstat之外的所有命令。具体的替换规则你可以参考下表。</p>
<p>至于jstat的功能，虽然jcmd复制了jstat的部分代码，并支持通过PerfCounter.print子命令来打印所有的 Performance Counter，但是它没有保留jstat的输出格式，也没有重复打印的功能。因此，感兴趣的同学可以自行整理。</p>
<p>另外，我们将在下一篇中介绍jcmd中 Java Flight Recorder 相关的子命令。</p>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>今天我介绍了 JDK 中用于监控及诊断的命令行工具。我们再来回顾一下。</p>
<ol>
<li>jps将打印所有正在运行的 Java 进程。</li>
<li>jstat允许用户查看目标 Java 进程的类加载、即时编译以及垃圾回收相关的信息。它常用于检测垃圾回收问题以及内存泄漏问题。</li>
<li>jmap允许用户统计目标 Java 进程的堆中存放的 Java 对象，并将它们导出成二进制文件。</li>
<li>jinfo将打印目标 Java 进程的配置参数，并能够改动其中 manageabe 的参数。</li>
<li>jstack将打印目标 Java 进程中各个线程的栈轨迹、线程状态、锁状况等信息。它还将自动检测死锁。</li>
<li>jcmd则是一把瑞士军刀，可以用来实现前面除了jstat之外所有命令的功能。</li>
</ol>
<p>今天的实践环节，你可以探索jcmd中的下述功能，看看有没有适合你项目的监控项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Compiler.CodeHeap_Analytics</span><br><span class="line">Compiler.codecache</span><br><span class="line">Compiler.codelist</span><br><span class="line">Compiler.directives_add</span><br><span class="line">Compiler.directives_clear</span><br><span class="line">Compiler.directives_print</span><br><span class="line">Compiler.directives_remove</span><br><span class="line">Compiler.queue</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.finalizer_info</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.heap_info</span><br><span class="line">GC.run</span><br><span class="line">GC.run_finalization</span><br><span class="line">VM.class_hierarchy</span><br><span class="line">VM.classloader_stats</span><br><span class="line">VM.classloaders</span><br><span class="line">VM.command_line</span><br><span class="line">VM.dynlibs</span><br><span class="line">VM.flags</span><br><span class="line">VM.info</span><br><span class="line">VM.<span class="built_in">log</span></span><br><span class="line">VM.metaspace</span><br><span class="line">VM.native_memory</span><br><span class="line">VM.print_touched_methods</span><br><span class="line">VM.set_flag</span><br><span class="line">VM.stringtable</span><br><span class="line">VM.symboltable</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.systemdictionary</span><br><span class="line">VM.unlock_commercial_features</span><br><span class="line">VM.<span class="built_in">uptime</span></span><br><span class="line">VM.version</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-29/" class="post-title-link" itemprop="url">29 | 基准测试框架JMH（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 16:42:53" itemprop="dateCreated datePublished" datetime="2020-01-23T16:42:53+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-RsFgNBND" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-RsFgNBND"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频29",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/0c/c2/0cc7f4a0c58d802ef006f1c803ce47c2.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们来继续学习基准测试框架 JMH。</p>
<h1 id="Fork-和-BenchmarkMode"><a href="#Fork-和-BenchmarkMode" class="headerlink" title="@Fork 和 @BenchmarkMode"></a>@Fork 和 @BenchmarkMode</h1><p>在上一篇的末尾，我们已经运行过由 JMH 项目编译生成的 jar 包了。下面是它的输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar target/benchmarks.jar</span><br><span class="line">...</span><br><span class="line"><span class="comment"># JMH version: 1.21</span></span><br><span class="line"><span class="comment"># VM version: JDK 10.0.2, Java HotSpot(TM) 64-Bit Server VM, 10.0.2+13</span></span><br><span class="line"><span class="comment"># VM invoker: /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home/bin/java</span></span><br><span class="line"><span class="comment"># VM options: &lt;none&gt;</span></span><br><span class="line"><span class="comment"># Warmup: 5 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Measurement: 5 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Timeout: 10 min per iteration</span></span><br><span class="line"><span class="comment"># Threads: 1 thread, will synchronize iterations</span></span><br><span class="line"><span class="comment"># Benchmark mode: Throughput, ops/time</span></span><br><span class="line"><span class="comment"># Benchmark: org.sample.MyBenchmark.testMethod</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Run progress: 0,00% complete, ETA 00:08:20</span></span><br><span class="line"><span class="comment"># Fork: 1 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 1023500,647 ops/s</span></span><br><span class="line"><span class="comment"># Warmup Iteration   2: 1030767,909 ops/s</span></span><br><span class="line"><span class="comment"># Warmup Iteration   3: 1018212,559 ops/s</span></span><br><span class="line"><span class="comment"># Warmup Iteration   4: 1002045,519 ops/s</span></span><br><span class="line"><span class="comment"># Warmup Iteration   5: 1004210,056 ops/s</span></span><br><span class="line">Iteration   1: 1010251,342 ops/s</span><br><span class="line">Iteration   2: 1005717,344 ops/s</span><br><span class="line">Iteration   3: 1004751,523 ops/s</span><br><span class="line">Iteration   4: 1003034,640 ops/s</span><br><span class="line">Iteration   5: 997003,830 ops/s</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Run progress: 20,00% complete, ETA 00:06:41</span></span><br><span class="line"><span class="comment"># Fork: 2 of 5</span></span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Run progress: 80,00% complete, ETA 00:01:40</span></span><br><span class="line"><span class="comment"># Fork: 5 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 988321,959 ops/s</span></span><br><span class="line"><span class="comment"># Warmup Iteration   2: 999486,531 ops/s</span></span><br><span class="line"><span class="comment"># Warmup Iteration   3: 1004856,886 ops/s</span></span><br><span class="line"><span class="comment"># Warmup Iteration   4: 1004810,860 ops/s</span></span><br><span class="line"><span class="comment"># Warmup Iteration   5: 1002332,077 ops/s</span></span><br><span class="line">Iteration   1: 1011871,670 ops/s</span><br><span class="line">Iteration   2: 1002653,844 ops/s</span><br><span class="line">Iteration   3: 1003568,030 ops/s</span><br><span class="line">Iteration   4: 1002724,752 ops/s</span><br><span class="line">Iteration   5: 1001507,408 ops/s</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Result <span class="string">&quot;org.sample.MyBenchmark.testMethod&quot;</span>:</span><br><span class="line">  1004801,393 ±(99.9%) 4055,462 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (992193,459, 1004801,393, 1014504,226), stdev = 5413,926</span><br><span class="line">  CI (99.9%): [1000745,931, 1008856,856] (assumes normal distribution)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Run complete. Total time: 00:08:22</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">Benchmark                Mode  Cnt        Score      Error  Units</span><br><span class="line">MyBenchmark.testMethod  thrpt   25  1004801,393 ± 4055,462  ops/s</span><br></pre></td></tr></table></figure>

<p>在上面这段输出中，我们暂且忽略最开始的 Warning 以及打印出来的配置信息，直接看接下来貌似重复的五段输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Run progress: <span class="number">0</span>,<span class="number">00</span>% complete, ETA <span class="number">00</span>:08:<span class="number">20</span></span><br><span class="line"># Fork: <span class="number">1</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1023500</span>,<span class="number">647</span> ops/s</span><br><span class="line"># Warmup Iteration   <span class="number">2</span>: <span class="number">1030767</span>,<span class="number">909</span> ops/s</span><br><span class="line"># Warmup Iteration   <span class="number">3</span>: <span class="number">1018212</span>,<span class="number">559</span> ops/s</span><br><span class="line"># Warmup Iteration   <span class="number">4</span>: <span class="number">1002045</span>,<span class="number">519</span> ops/s</span><br><span class="line"># Warmup Iteration   <span class="number">5</span>: <span class="number">1004210</span>,<span class="number">056</span> ops/s</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1010251</span>,<span class="number">342</span> ops/s</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1005717</span>,<span class="number">344</span> ops/s</span><br><span class="line">Iteration   <span class="number">3</span>: <span class="number">1004751</span>,<span class="number">523</span> ops/s</span><br><span class="line">Iteration   <span class="number">4</span>: <span class="number">1003034</span>,<span class="number">640</span> ops/s</span><br><span class="line">Iteration   <span class="number">5</span>: <span class="number">997003</span>,<span class="number">830</span> ops/s</span><br></pre></td></tr></table></figure>

<p>你应该已经留意到Fork: 1 of 5的字样。这里指的是 JMH 会 Fork 出一个新的 Java 虚拟机，来运行性能基准测试。</p>
<p>之所以另外启动一个 Java 虚拟机进行性能基准测试，是为了获得一个相对干净的虚拟机环境。</p>
<p>在介绍反射的那篇文章中，我就已经演示过因为类型 profile 被污染，而导致无法内联的情况。使用新的虚拟机，将极大地降低被上述情况干扰的可能性，从而保证更加精确的性能数据。</p>
<p>在介绍虚方法内联的那篇文章中，我讲解过基于类层次分析的完全内联。新启动的 Java 虚拟机，其加载的与测试无关的抽象类子类或接口实现相对较少。因此，具体是否进行完全内联将交由开发人员来决定。</p>
<p>关于这种情况，JMH 提供了一个性能测试案例 [1]。如果你感兴趣的话，可以下载下来自己跑一遍。</p>
<p>除了对即时编译器的影响之外，Fork 出新的 Java 虚拟机还会提升性能数据的准确度。</p>
<p>这主要是因为不少 Java 虚拟机的优化会带来不确定性，例如 TLAB 内存分配（TLAB 的大小会变化），偏向锁、轻量锁算法，并发数据结构等。这些不确定性都可能导致不同 Java 虚拟机中运行的性能测试的结果不同，例如 JMH 这一性能的测试案例 [2]。</p>
<p>在这种情况下，通过运行更多的 Fork，并将每个 Java 虚拟机的性能测试结果平均起来，可以增强最终数据的可信度，使其误差更小。在 JMH 中，你可以通过@Fork注解来配置，具体如下述代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Fork(10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们回到刚刚的输出结果。每个 Fork 包含了 5 个预热迭代（warmup iteration，如# Warmup Iteration 1: 1023500,647 ops&#x2F;s）以及 5 个测试迭代（measurement iteration，如Iteration   1: 1010251,342 ops&#x2F;s）。</p>
<p>每个迭代后都跟着一个数据，代表本次迭代的吞吐量，也就是每秒运行了多少次操作（operations&#x2F;s，或 ops&#x2F;s）。默认情况下，一次操作指的是调用一次测试方法testMethod。</p>
<p>除了吞吐量之外，我们还可以输出其他格式的性能数据，例如运行一次操作的平均时间。具体的配置方法以及对应参数如下述代码以及下表所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，默认使用的吞吐量已足够满足大多数测试需求了。</p>
<h1 id="Warmup-和-Measurement"><a href="#Warmup-和-Measurement" class="headerlink" title="@Warmup 和 @Measurement"></a>@Warmup 和 @Measurement</h1><p>之所以区分预热迭代和测试迭代，是为了在记录性能数据之前，将 Java 虚拟机带至一个稳定状态。</p>
<p>这里的稳定状态，不仅包括测试方法被即时编译成机器码，还包括 Java 虚拟机中各种自适配优化算法能够稳定下来，如前面提到的 TLAB 大小，亦或者是使用传统垃圾回收器时的 Eden 区、Survivor 区和老年代的大小。</p>
<p>一般来说，预热迭代的数目以及每次预热迭代的时间，需要由你根据所要测试的业务逻辑代码来调配。通常的做法便是在首次运行时配置较多次迭代，并监控性能数据达到稳定状态时的迭代数目。</p>
<p>不少性能评测框架都会自动检测稳定状态。它们所采用的算法是计算迭代之间的差值，如果连续几个迭代与前一迭代的差值均小于某个值，便将这几个迭代以及之后的迭代当成稳定状态。</p>
<p>这种做法有一个缺陷，那便是在达到最终稳定状态前，程序可能拥有多个中间稳定状态。例如通过 Java 上的 JavaScript 引擎 Nashorn 运行 JavaScript 代码，便可能出现多个中间稳定状态的情况。（具体可参考 Aleksey Shipilev 的 devoxx 2013 演讲 [3] 的第 21 页。）</p>
<p>总而言之，开发人员需要自行决定预热迭代的次数以及每次迭代的持续时间。</p>
<p>通常来说，我会在保持 5-10 个预热迭代的前提下（这样可以看出是否达到稳定状况），将总的预热时间优化至最少，以便节省性能测试的机器时间。（这在持续集成 &#x2F; 回归测试的硬件资源跟不上代码提交速度的团队中非常重要。）</p>
<p>当确定了预热迭代的次数以及每次迭代的持续时间之后，我们便可以通过@Warmup注解来进行配置，如下述代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations=10, time=100, timeUnit=TimeUnit.MILLISECONDS, batchSize=10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Warmup注解有四个参数，分别为预热迭代的次数iterations，每次迭代持续的时间time和timeUnit（前者是数值，后者是单位。例如上面代码代表的是每次迭代持续 100 毫秒），以及每次操作包含多少次对测试方法的调用batchSize。</p>
<p>测试迭代可通过@Measurement注解来进行配置。它的可配置选项和@Warmup的一致，这里就不再重复了。与预热迭代不同的是，每个 Fork 中测试迭代的数目越多，我们得到的性能数据也就越精确。</p>
<p>@State、@Setup 和 @TearDown<br>通常来说，我们所要测试的业务逻辑只是整个应用程序中的一小部分，例如某个具体的 web app 请求。这要求在每次调用测试方法前，程序处于准备接收请求的状态。</p>
<p>我们可以把上述场景抽象一下，变成程序从某种状态到另一种状态的转换，而性能测试，便是在收集该转换的性能数据。</p>
<p>JMH 提供了@State注解，被它标注的类便是程序的状态。由于 JMH 将负责生成这些状态类的实例，因此，它要求状态类必须拥有无参数构造器，以及当状态类为内部类时，该状态类必须是静态的。</p>
<p>JMH 还将程序状态细分为整个虚拟机的程序状态，线程私有的程序状态，以及线程组私有的程序状态，分别对应@State注解的参数Scope.Benchmark，Scope.Thread和Scope.Group。</p>
<p>需要注意的是，这里的线程组并非 JDK 中的那个概念，而是 JMH 自己定义的概念。具体可以参考@GroupThreads注解 [4]，以及这个案例 [5]。</p>
<p>@State的配置方法以及状态类的用法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line">    <span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBenchmarkState</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;exception&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(MyBenchmarkState state)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Exception</span>(state.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，状态类是通过方法参数的方式传入测试方法之中的。JMH 将负责把所构造的状态类实例传入该方法之中。</p>
<p>不过，如果MyBenchmark被标注为@State，那么我们可以不用在测试方法中定义额外的参数，而是直接访问MyBenchmark类中的实例变量。</p>
<p>和 JUnit 测试一样，我们可以在测试前初始化程序状态，在测试后校验程序状态。这两种操作分别对应@Setup和@TearDown注解，被它们标注的方法必须是状态类中的方法。</p>
<p>而且，JMH 并不限定状态类中@Setup方法以及@TearDown方法的数目。当存在多个@Setup方法或者@TearDown方法时，JMH 将按照定义的先后顺序执行。</p>
<p>JMH 对@Setup方法以及@TearDown方法的调用时机是可配置的。可供选择的粒度有在整个性能测试前后调用，在每个迭代前后调用，以及在每次调用测试方法前后调用。其中，最后一个粒度将影响测试数据的精度。</p>
<p>这三种粒度分别对应@Setup和@TearDown注解的参数Level.Trial，Level.Iteration，以及Level.Invocation。具体的用法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line">  <span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBenchmarkState</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Setup(Level.Invocation)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@TearDown(Level.Invocation)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// Run with -ea</span></span><br><span class="line">      <span class="keyword">assert</span> count == <span class="number">1</span> : <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(MyBenchmarkState state)</span> &#123;</span><br><span class="line">    state.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="即时编译相关功能"><a href="#即时编译相关功能" class="headerlink" title="即时编译相关功能"></a>即时编译相关功能</h1><p>JMH 还提供了不少控制即时编译的功能，例如可以控制每个方法内联与否的@CompilerControl注解 [6]。</p>
<p>另外一个更小粒度的功能则是Blackhole类。它里边的consume方法可以防止即时编译器将所传入的值给优化掉。</p>
<p>具体的使用方法便是为被@Benchmark注解标注了的测试方法增添一个类型为Blackhole的参数，并且在测试方法的代码中调用其实例方法Blackhole.consume，如下述代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(Blackhole bh)</span> &#123;</span><br><span class="line">  bh.consume(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// prevents escape analysis</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，它并不会阻止对传入值的计算的优化。举个例子，在下面这段代码中，我将3+4的值传入Blackhole.consume方法中。即时编译器仍旧会进行常量折叠，而Blackhole将阻止即时编译器把所得到的常量值 7 给优化消除掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(Blackhole bh)</span> &#123;</span><br><span class="line">  bh.consume(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了防止死代码消除的consume之外，Blackhole类还提供了一个静态方法consumeCPU，来消耗 CPU 时间。该方法将接收一个 long 类型的参数，这个参数与所消耗的 CPU 时间呈线性相关。</p>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>今天我介绍了基准测试框架 JMH 的进阶功能。我们来回顾一下。</p>
<p>@Fork允许开发人员指定所要 Fork 出的 Java 虚拟机的数目。<br>@BenchmarkMode允许指定性能数据的格式。<br>@Warmup和@Measurement允许配置预热迭代或者测试迭代的数目，每个迭代的时间以及每个操作包含多少次对测试方法的调用。<br>@State允许配置测试程序的状态。测试前对程序状态的初始化以及测试后对程序状态的恢复或者校验可分别通过@Setup和@TearDown来实现。<br>今天的实践环节，请逐个运行 JMH 的官方案例 [7]，具体每个案例的意义都在代码注释之中。</p>
<p>最后给大家推荐一下 Aleksey Shipilev 的 devoxx 2013 演讲（Slides[8]；视频 [9]，请自备梯子）。如果你已经完成本专栏前面两部分，特别是第二部分的学习，那么这个演讲里的绝大部分内容你应该都能理解。</p>
<p>[1] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_12_Forking.java">http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_12_Forking.java</a><br>[2] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_13_RunToRun.java">http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_13_RunToRun.java</a><br>[3] <a href="https://shipilev.net/talks/devoxx-Nov2013-benchmarking.pdf">https://shipilev.net/talks/devoxx-Nov2013-benchmarking.pdf</a><br>[4] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-core/src/main/java/org/openjdk/jmh/annotations/GroupThreads.java">http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-core/src/main/java/org/openjdk/jmh/annotations/GroupThreads.java</a><br>[5] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_15_Asymmetric.java">http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_15_Asymmetric.java</a><br>[6] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-core/src/main/java/org/openjdk/jmh/annotations/CompilerControl.java">http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-core/src/main/java/org/openjdk/jmh/annotations/CompilerControl.java</a><br>[7] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-samples/src/main/java/org/openjdk/jmh/samples">http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-samples/src/main/java/org/openjdk/jmh/samples</a><br>[8] <a href="https://shipilev.net/talks/devoxx-Nov2013-benchmarking.pdf">https://shipilev.net/talks/devoxx-Nov2013-benchmarking.pdf</a><br>[9] <a href="https://www.youtube.com/watch?v=VaWgOCDBxYw">https://www.youtube.com/watch?v=VaWgOCDBxYw</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-28/" class="post-title-link" itemprop="url">28 | 基准测试框架JMH（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 16:37:22" itemprop="dateCreated datePublished" datetime="2020-01-23T16:37:22+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-OvkvUskc" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-OvkvUskc"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频28",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/8c/63/8c9c5dfa9a6b815568f00314755ad463.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们来聊聊性能基准测试（benchmarking）。</p>
<p>大家或许都看到过一些不严谨的性能测试，以及基于这些测试结果得出的令人匪夷所思的结论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">1_000_000_000</span>) &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，上面这段代码中的foo方法，将进行 10^9 次加法操作及跳转操作。</p>
<p>不少开发人员，包括我在介绍反射调用那一篇中所做的性能测试，都使用了下面这段代码的测量方式，即通过System.nanoTime或者System.currentTimeMillis来测量每若干个操作（如连续调用 1000 次foo方法）所花费的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopPerformanceTest</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// warmup</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20_000</span>; i++) &#123;</span><br><span class="line">      foo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// measurement</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10_000</span>; i++) &#123;</span><br><span class="line">      foo();</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = System.nanoTime();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种测量方式实际上过于理性化，忽略了 Java 虚拟机、操作系统，乃至硬件系统所带来的影响。</p>
<h1 id="性能测试的坑"><a href="#性能测试的坑" class="headerlink" title="性能测试的坑"></a>性能测试的坑</h1><p>关于 Java 虚拟机所带来的影响，我们在前面的篇章中已经介绍过不少，如 Java 虚拟机堆空间的自适配，即时编译等。</p>
<p>在上面这段代码中，真正进行测试的代码（即&#x2F;&#x2F; measurement后的代码）由于循环次数不多，属于冷循环，没有能触发 OSR 编译。</p>
<p>也就是说，我们会在main方法中解释执行，然后调用foo方法即时编译生成的机器码中。这种混杂了解释执行以及即时编译生成代码的测量方式，其得到的数据含义不明。</p>
<p>有同学认为，我们可以假设foo方法耗时较长（毕竟 10^9 次加法），因此main方法的解释执行并不会对最终计算得出的性能数据造成太大影响。上面这段代码在我的机器上测出的结果是，每 1000 次foo方法调用在 20 微秒左右。</p>
<p>这是否意味着，我这台机器的 CPU 已经远超它的物理限制，其频率达到 100,000,000 GHz 了。（假设循环主体就两条指令，每时钟周期指令数 [1] 为 1。）这显然是不可能的，目前 CPU 单核的频率大概在 2-5 GHz 左右，再怎么超频也不可能提升七八个数量级。</p>
<p>你应该能够猜到，这和即时编译器的循环优化有关。下面便是foo方法的编译结果。我们可以看到，它将直接返回 10^9，而不是循环 10^9 次，并在循环中重复进行加法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x8aa0</span>: sub    rsp,<span class="number">0x18</span>                 <span class="comment">// 创建方法栈桢</span></span><br><span class="line"><span class="number">0x8aa7</span>: mov    QWORD PTR [rsp+<span class="number">0x10</span>],rbp <span class="comment">// 无关指令</span></span><br><span class="line"><span class="number">0x8aac</span>: mov    eax,<span class="number">0x3b9aca00</span>           <span class="comment">// return 10^9</span></span><br><span class="line"><span class="number">0x8ab1</span>: add    rsp,<span class="number">0x10</span>                 <span class="comment">// 弹出方法栈桢</span></span><br><span class="line"><span class="number">0x8ab5</span>: pop    rbp                      <span class="comment">// 无关指令</span></span><br><span class="line"><span class="number">0x8ab6</span>: mov    r10,QWORD PTR [r15+<span class="number">0x70</span>] <span class="comment">// 安全点测试</span></span><br><span class="line"><span class="number">0x8aba</span>: test   DWORD PTR [r10],eax      <span class="comment">// 安全点测试</span></span><br><span class="line"><span class="number">0x8abd</span>: ret</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之前我忘记解释所谓的”无关指令“是什么意思。我指的是该指令和具体的代码逻辑无关。即时编译器生成的代码可能会将 RBP 寄存器作为通用寄存器，从而是寄存器分配算法有更多的选择。由于调用者（caller）未必保存了 RBP 寄存器的值，所以即时编译器会在进入被调用者（callee）时保存 RBP 的值，并在退出被调用者时复原 RBP 的值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">1_000_000_000</span>) &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化为</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1_000_000_000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该循环优化并非循环展开。在默认情况下，即时编译器仅能将循环展开 60 次（对应虚拟机参数-XX:LoopUnrollLimit）。实际上，在介绍循环优化那篇文章中，我并没有提及这个优化。因为该优化实在是太过于简单，几乎所有开发人员都能够手工对其进行优化。</p>
<p>在即时编译器中，它是一个基于计数循环的优化。我们也已经学过计数循环的知识。也就是说，只要将循环变量i改为 long 类型，便可以“避免”这个优化。</p>
<p>关于操作系统和硬件系统所带来的影响，一个较为常见的例子便是电源管理策略。在许多机器，特别是笔记本上，操作系统会动态配置 CPU 的频率。而 CPU 的频率又直接影响到性能测试的数据，因此短时间的性能测试得出的数据未必可靠。</p>
<p><img src="/images/2020/01/23/a2ac3e70-3dba-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>例如我的笔记本，在刚开始进行性能评测时，单核频率可以达到 4.0 GHz。而后由于 CPU 温度升高，频率便被限制在 3.0 GHz 了。</p>
<p>除了电源管理之外，CPU 缓存、分支预测器 [2]，以及超线程技术 [3]，都会对测试结果造成影响。</p>
<p>就 CPU 缓存而言，如果程序的数据本地性较好，那么它的性能指标便会非常好；如果程序存在 false sharing 的问题，即几个线程写入内存中属于同一缓存行的不同部分，那么它的性能指标便会非常糟糕。</p>
<p>超线程技术是另一个可能误导性能测试工具的因素。我们知道，超线程技术将为每个物理核心虚拟出两个虚拟核心，从而尽可能地提高物理核心的利用率。如果性能测试的两个线程被安排在同一物理核心上，那么得到的测试数据显然要比被安排在不同物理核心上的数据糟糕得多。</p>
<p>总而言之，性能基准测试存在着许多深坑（pitfall）。然而，除了性能测试专家外，大多数开发人员都没有足够全面的知识，能够绕开这些坑，因而得出的性能测试数据很有可能是有偏差的（biased）。</p>
<p>下面我将介绍 OpenJDK 中的开源项目 JMH[4]（Java Microbenchmark Harness）。JMH 是一个面向 Java 语言或者其他 Java 虚拟机语言的性能基准测试框架。它针对的是纳秒级别（出自官网介绍，个人觉得精确度没那么高）、微秒级别、毫秒级别，以及秒级别的性能测试。</p>
<p>由于许多即时编译器的开发人员参与了该项目，因此 JMH 内置了许多功能来控制即时编译器的优化。对于其他影响性能评测的因素，JMH 也提供了不少策略来降低影响，甚至是彻底解决。</p>
<p>因此，使用这个性能基准测试框架的开发人员，可以将精力完全集中在所要测试的业务逻辑，并以最小的代价控制除了业务逻辑之外的可能影响性能的因素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial experiments, perform baseline and negative tests that provide experimental control, make sure the benchmarking environment is safe on JVM/OS/HW level, ask <span class="keyword">for</span> reviews from the domain experts. Do not assume the numbers tell you what you want them to tell.</span><br></pre></td></tr></table></figure>

<p>不过，JMH 也不能完美解决性能测试数据的偏差问题。它甚至会在每次运行的输出结果中打印上述语句，所以，JMH 的开发人员也给出了一个小忠告：我们开发人员不要轻信 JMH 的性能测试数据，不要基于这些数据乱下结论。</p>
<p>通常来说，性能基准测试的结果反映的是所测试的业务逻辑在所运行的 Java 虚拟机，操作系统，硬件系统这一组合上的性能指标，而根据这些性能指标得出的通用结论则需要经过严格论证。</p>
<p>在理解（或忽略）了 JMH 的忠告后，我们下面便来看看如何使用 JMH。</p>
<h1 id="生成-JMH-项目"><a href="#生成-JMH-项目" class="headerlink" title="生成 JMH 项目"></a>生成 JMH 项目</h1><p>JMH 的使用方式并不复杂。我们可以借助 JMH 部署在 maven 上的 archetype，生成预设好依赖关系的 maven 项目模板。具体的命令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate \</span><br><span class="line">          -DinteractiveMode=<span class="literal">false</span> \</span><br><span class="line">          -DarchetypeGroupId=org.openjdk.jmh \</span><br><span class="line">          -DarchetypeArtifactId=jmh-java-benchmark-archetype \</span><br><span class="line">          -DgroupId=org.sample \</span><br><span class="line">          -DartifactId=<span class="built_in">test</span> \</span><br><span class="line">          -Dversion=1.21</span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>该命令将在当前目录下生成一个test文件夹（对应参数-DartifactId&#x3D;test，可更改），其中便包含了定义该 maven 项目依赖的pom.xml文件，以及自动生成的测试文件src&#x2F;main&#x2F;org&#x2F;sample&#x2F;MyBenchmark.java（这里org&#x2F;sample对应参数-DgroupId&#x3D;org.sample，可更改）。后者的内容如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> org.sample;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.Benchmark;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// This is a demo/sample template for building your JMH benchmarks. Edit as needed.</span></span><br><span class="line">        <span class="comment">// Put your benchmark code here.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面，类名MyBenchmark以及方法名testMethod并不重要，你可以随意更改。真正重要的是@Benchmark注解。被它标注的方法，便是 JMH 基准测试的测试方法。该测试方法默认是空的。我们可以填入需要进行性能测试的业务逻辑。</p>
<p>举个例子，我们可以测量新建异常对象的性能，如下述代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，我们不应该使用这种貌似会被即时编译器优化掉的代码（在下篇中我会介绍 JMH 的Blackhole功能）。</p>
<p>不过，我们已经学习过逃逸分析了，知道 native 方法调用的调用者或者参数会被识别为逃逸。而Exception的构造器将间接调用至 native 方法fillInStackTrace中，并且该方法调用的调用者便是新建的Exception对象。因此，逃逸分析将判定该新建对象逃逸，而即时编译器也无法优化掉原本的新建对象操作。</p>
<p>当Exception的构造器返回时，Java 虚拟机将不再拥有指向这一新建对象的引用。因此，该新建对象可以被垃圾回收。</p>
<h1 id="编译和运行-JMH-项目"><a href="#编译和运行-JMH-项目" class="headerlink" title="编译和运行 JMH 项目"></a>编译和运行 JMH 项目</h1><p>在上一篇介绍注解处理器时，我曾提到过，JMH 正是利用注解处理器 [5] 来自动生成性能测试的代码。实际上，除了@Benchmark之外，JMH 的注解处理器还将处理所有位于org.openjdk.jmh.annotations包 [6] 下的注解。（其他注解我们会在下一篇中详细介绍。）</p>
<p>我们可以运行mvn compile命令来编译这个 maven 项目。该命令将生成target文件夹，其中的generated-sources目录便存放着由 JMH 的注解处理器所生成的 Java 源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mvn compile</span><br><span class="line">$ ls target/generated-sources/annotations/org/sample/generated/</span><br><span class="line">MyBenchmark_jmhType.java            MyBenchmark_jmhType_B1.java         MyBenchmark_jmhType_B2.java         MyBenchmark_jmhType_B3.java         MyBenchmark_testMethod_jmhTest.java</span><br></pre></td></tr></table></figure>
<p>在这些源代码里，所有以MyBenchmark_jmhType为前缀的 Java 类都继承自MyBenchmark。这是注解处理器的常见用法，即通过生成子类来将注解所带来的额外语义扩张成方法。</p>
<p>具体来说，它们之间的继承关系是MyBenchmark_jmhType -&gt; B3 -&gt; B2 -&gt; B1 -&gt; MyBenchmark（这里A -&gt; B代表 A 继承 B）。其中，B2 存放着 JMH 用来控制基准测试的各项字段。</p>
<p>为了避免这些控制字段对MyBenchmark类中的字段造成 false sharing 的影响，JMH 生成了 B1 和 B3，分别存放了 256 个 boolean 字段，从而避免 B2 中的字段与MyBenchmark类、MyBenchmark_jmhType类中的字段（或内存里下一个对象中的字段）会出现在同一缓存行中。</p>
<blockquote>
<p>之所以不能在同一类中安排这些字段，是因为 Java 虚拟机的字段重排列。而类之间的继承关系，便可以避免不同类所包含的字段之间的重排列。</p>
</blockquote>
<p>除了这些jmhType源代码外，generated-sources目录还存放着真正的性能测试代码MyBenchmark_testMethod_jmhTest.java。当进行性能测试时，Java 虚拟机所运行的代码很有可能便是这一个源文件中的热循环经过 OSR 编译过后的代码。</p>
<blockquote>
<p>在通过 CompileCommand 分析即时编译后的机器码时，我们需要关注的其实是MyBenchmark_testMethod_jmhTest中的方法。</p>
</blockquote>
<p>由于这里面的内容过于复杂，我将在下一篇中介绍影响该生成代码的众多功能性注解，这里就不再详细进行介绍了。</p>
<p>接下来，我们可以运行mvn package命令，将编译好的 class 文件打包成 jar 包。生成的 jar 包同样位于target目录下，其名字为benchmarks.jar。jar 包里附带了一系列配置文件，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ mvn package</span><br><span class="line"> </span><br><span class="line">$ jar tf target/benchmarks.jar META-INF</span><br><span class="line">META-INF/MANIFEST.MF</span><br><span class="line">META-INF/</span><br><span class="line">META-INF/BenchmarkList</span><br><span class="line">META-INF/CompilerHints</span><br><span class="line">META-INF/maven/</span><br><span class="line">META-INF/maven/org.sample/</span><br><span class="line">META-INF/maven/org.sample/test/</span><br><span class="line">META-INF/maven/org.sample/test/pom.xml</span><br><span class="line">META-INF/maven/org.sample/test/pom.properties</span><br><span class="line">META-INF/maven/org.openjdk.jmh/</span><br><span class="line">META-INF/maven/org.openjdk.jmh/jmh-core/</span><br><span class="line">META-INF/maven/org.openjdk.jmh/jmh-core/pom.xml</span><br><span class="line">META-INF/maven/org.openjdk.jmh/jmh-core/pom.properties</span><br><span class="line">META-INF/maven/net.sf.jopt-simple/</span><br><span class="line">META-INF/maven/net.sf.jopt-simple/jopt-simple/</span><br><span class="line">META-INF/maven/net.sf.jopt-simple/jopt-simple/pom.xml</span><br><span class="line">META-INF/maven/net.sf.jopt-simple/jopt-simple/pom.properties</span><br><span class="line">META-INF/LICENSE.txt</span><br><span class="line">META-INF/NOTICE.txt</span><br><span class="line">META-INF/maven/org.apache.commons/</span><br><span class="line">META-INF/maven/org.apache.commons/commons-math3/</span><br><span class="line">META-INF/maven/org.apache.commons/commons-math3/pom.xml</span><br><span class="line">META-INF/maven/org.apache.commons/commons-math3/pom.properties</span><br><span class="line"> </span><br><span class="line">$ unzip -c target/benchmarks.jar META-INF/MANIFEST.MF</span><br><span class="line">Archive:  target/benchmarks.jar</span><br><span class="line">  inflating: META-INF/MANIFEST.MF    </span><br><span class="line">Manifest-Version: 1.0</span><br><span class="line">Archiver-Version: Plexus Archiver</span><br><span class="line">Created-By: Apache Maven 3.5.4</span><br><span class="line">Built-By: zhengy</span><br><span class="line">Build-Jdk: 10.0.2</span><br><span class="line">Main-Class: org.openjdk.jmh.Main</span><br><span class="line"> </span><br><span class="line">$ unzip -c target/benchmarks.jar META-INF/BenchmarkList</span><br><span class="line">Archive:  target/benchmarks.jar</span><br><span class="line">  inflating: META-INF/BenchmarkList  </span><br><span class="line">JMH S 22 org.sample.MyBenchmark S 51 org.sample.generated.MyBenchmark_testMethod_jmhTest S 10 testMethod S 10 Throughput E A 1 1 1 E E E E E E E E E E E E E E E E E</span><br><span class="line"> </span><br><span class="line">$ unzip -c target/benchmarks.jar META-INF/CompilerHints</span><br><span class="line">Archive:  target/benchmarks.jar</span><br><span class="line">  inflating: META-INF/CompilerHints  </span><br><span class="line">dontinline,*.*_all_jmhStub</span><br><span class="line">dontinline,*.*_avgt_jmhStub</span><br><span class="line">dontinline,*.*_sample_jmhStub</span><br><span class="line">dontinline,*.*_ss_jmhStub</span><br><span class="line">dontinline,*.*_thrpt_jmhStub</span><br><span class="line">inline,org/sample/MyBenchmark.testMethod</span><br></pre></td></tr></table></figure>

<p>这里我展示了其中三个比较重要的配置文件。</p>
<ol>
<li>MANIFEST.MF中指定了该 jar 包的默认入口，即org.openjdk.jmh.Main[7]。</li>
<li>BenchmarkList中存放了测试配置。该配置是根据MyBenchmark.java里的注解自动生成的，具体我会在下一篇中详细介绍源代码中如何配置。</li>
<li>CompilerHints中存放了传递给 Java 虚拟机的-XX:CompileCommandFile参数的内容。它规定了无法内联以及必须内联的几个方法，其中便有存放业务逻辑的测试方法testMethod。</li>
</ol>
<p>在编译MyBenchmark_testMethod_jmhTest类中的测试方法时，JMH 会让即时编译器强制内联对MyBenchmark.testMethod的方法调用，以避免调用开销。</p>
<p>打包生成的 jar 包可以直接运行。具体指令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar target/benchmarks.jar</span><br><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">...</span><br><span class="line">Benchmark                Mode  Cnt        Score      Error  Units</span><br><span class="line">MyBenchmark.testMethod  thrpt   25  1004801,393 ± 4055,462  ops/s</span><br></pre></td></tr></table></figure>

<p>这里 JMH 会有非常多的输出，具体内容我会在下一篇中进行讲解。</p>
<p>输出的最后便是本次基准测试的结果。其中比较重要的两项指标是Score和Error，分别代表本次基准测试的平均吞吐量（每秒运行testMethod方法的次数）以及误差范围。例如，这里的结果说明本次基准测试平均每秒生成 10^6 个异常实例，误差范围大致在 4000 个异常实例。</p>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>今天我介绍了 OpenJDK 的性能基准测试项目 JMH。</p>
<p>Java 程序的性能测试存在着许多深坑，有来自 Java 虚拟机的，有来自操作系统的，甚至有来自硬件系统的。如果没有足够的知识，那么性能测试的结果很有可能是有偏差的。</p>
<p>性能基准测试框架 JMH 是 OpenJDK 中的其中一个开源项目。它内置了许多功能，来规避由 Java 虚拟机中的即时编译器或者其他优化对性能测试造成的影响。此外，它还提供了不少策略来降低来自操作系统以及硬件系统的影响。</p>
<p>开发人员仅需将所要测试的业务逻辑通过@Benchmark注解，便可以让 JMH 的注解处理器自动生成真正的性能测试代码，以及相应的性能测试配置文件。</p>
<p>今天的实践环节，请生成一个 JMH 项目，并且在MyBenchmark.testMethod方法中填入自己的业务逻辑。（除非你已经提前了解@State等 JMH 功能，否则请不要在MyBenchmark中定义实例变量。）</p>
<p>[1] <a href="https://en.wikipedia.org/wiki/Instructions_per_cycle">https://en.wikipedia.org/wiki/Instructions_per_cycle</a><br>[2] <a href="https://en.wikipedia.org/wiki/Branch_predictor">https://en.wikipedia.org/wiki/Branch_predictor</a><br>[3] <a href="https://en.wikipedia.org/wiki/Hyper-threading">https://en.wikipedia.org/wiki/Hyper-threading</a><br>[4] <a href="http://openjdk.java.net/projects/code-tools/jmh/">http://openjdk.java.net/projects/code-tools/jmh/</a><br>[5] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-generator-annprocess/src/main/java/org/openjdk/jmh/generators/BenchmarkProcessor.java">http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-generator-annprocess/src/main/java/org/openjdk/jmh/generators/BenchmarkProcessor.java</a><br>[6] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-core/src/main/java/org/openjdk/jmh/annotations">http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-core/src/main/java/org/openjdk/jmh/annotations</a><br>[7] <a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-core/src/main/java/org/openjdk/jmh/Main.java">http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-core/src/main/java/org/openjdk/jmh/Main.java</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-27/" class="post-title-link" itemprop="url">27 | 注解处理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 16:27:34" itemprop="dateCreated datePublished" datetime="2020-01-23T16:27:34+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-WgrcCZSI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-WgrcCZSI"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频27",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/8c/3d/8c26bebd8e5fa781cebcfe90ebfd943d.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>注解（annotation）是 Java 5 引入的，用来为类、方法、字段、参数等 Java 结构提供额外信息的机制。我先举个例子，比如，Java 核心类库中的@Override注解是被用来声明某个实例方法重写了父类的同名同参数类型的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Override注解本身被另外两个元注解（即作用在注解上的注解）所标注。其中，@Target用来限定目标注解所能标注的 Java 结构，这里@Override便只能被用来标注方法。</p>
<p>@Retention则用来限定当前注解生命周期。注解共有三种不同的生命周期：SOURCE，CLASS或RUNTIME，分别表示注解只出现在源代码中，只出现在源代码和字节码中，以及出现在源代码、字节码和运行过程中。</p>
<p>这里@Override便只能出现在源代码中。一旦标注了@Override的方法所在的源代码被编译为字节码，该注解便会被擦除。</p>
<p>我们不难猜到，@Override仅对 Java 编译器有用。事实上，它会为 Java 编译器引入了一条新的编译规则，即如果所标注的方法不是 Java 语言中的重写方法，那么编译器会报错。而当编译完成时，它的使命也就结束了。</p>
<p>我们知道，Java 的注解机制允许开发人员自定义注解。这些自定义注解同样可以为 Java 编译器添加编译规则。不过，这种功能需要由开发人员提供，并且以插件的形式接入 Java 编译器中，这些插件我们称之为注解处理器（annotation processor）。</p>
<p>除了引入新的编译规则之外，注解处理器还可以用于修改已有的 Java 源文件（不推荐），或者生成新的 Java 源文件。下面，我将用几个案例来详细阐述注解处理器的这些功能，以及它背后的原理。</p>
<h1 id="注解处理器的原理"><a href="#注解处理器的原理" class="headerlink" title="注解处理器的原理"></a>注解处理器的原理</h1><p>在介绍注解处理器之前，我们先来了解一下 Java 编译器的工作流程。</p>
<p><img src="/images/2020/01/23/633ce240-3db9-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>如上图所示 出处 [1]，Java 源代码的编译过程可分为三个步骤：</p>
<ol>
<li>将源文件解析为抽象语法树；</li>
<li>调用已注册的注解处理器；</li>
<li>生成字节码。</li>
</ol>
<p>如果在第 2 步调用注解处理器过程中生成了新的源文件，那么编译器将重复第 1、2 步，解析并且处理新生成的源文件。每次重复我们称之为一轮（Round）。</p>
<p>也就是说，第一轮解析、处理的是输入至编译器中的已有源文件。如果注解处理器生成了新的源文件，则开始第二轮、第三轮，解析并且处理这些新生成的源文件。当注解处理器不再生成新的源文件，编译进入最后一轮，并最终进入生成字节码的第 3 步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.FIELD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckGetter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，我定义了一个注解@CheckGetter。它既可以用来标注类，也可以用来标注字段。此外，它和@Override相同，其生命周期被限定在源代码中。</p>
<p>下面我们来实现一个处理@CheckGetter注解的处理器。它将遍历被标注的类中的实例字段，并检查有没有相应的getter方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment processingEnv)</span>;</span><br><span class="line">  </span><br><span class="line">  Set&lt;String&gt; <span class="title function_">getSupportedAnnotationTypes</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  SourceVersion <span class="title function_">getSupportedSourceVersion</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span>;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的注解处理器类都需要实现接口Processor。该接口主要有四个重要方法。其中，init方法用来存放注解处理器的初始化代码。之所以不用构造器，是因为在 Java 编译器中，注解处理器的实例是通过反射 API 生成的。也正是因为使用反射 API，每个注解处理器类都需要定义一个无参数构造器。</p>
<p>通常来说，当编写注解处理器时，我们不声明任何构造器，并依赖于 Java 编译器，为之插入一个无参数构造器。而具体的初始化代码，则放入init方法之中。</p>
<p>在剩下的三个方法中，getSupportedAnnotationTypes方法将返回注解处理器所支持的注解类型，这些注解类型只需用字符串形式表示即可。</p>
<p>getSupportedSourceVersion方法将返回该处理器所支持的 Java 版本，通常，这个版本需要与你的 Java 编译器版本保持一致；而process方法则是最为关键的注解处理方法。</p>
<p>JDK 提供了一个实现Processor接口的抽象类AbstractProcessor。该抽象类实现了init、getSupportedAnnotationTypes和getSupportedSourceVersion方法。</p>
<p>它的子类可以通过@SupportedAnnotationTypes和@SupportedSourceVersion注解来声明所支持的注解类型以及 Java 版本。</p>
<p>下面这段代码便是@CheckGetter注解处理器的实现。由于我使用了 Java 10 的编译器，因此将支持版本设置为SourceVersion.RELEASE_10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bar;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementFilter;</span><br><span class="line"><span class="keyword">import</span> javax.tools.Diagnostic.Kind;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> foo.CheckGetter;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;foo.CheckGetter&quot;)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckGetterProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> annotated ElementKind.FIELD</span></span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotatedClass : ElementFilter.typesIn(roundEnv.getElementsAnnotatedWith(CheckGetter.class))) &#123;</span><br><span class="line">      <span class="keyword">for</span> (VariableElement field : ElementFilter.fieldsIn(annotatedClass.getEnclosedElements())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!containsGetter(annotatedClass, field.getSimpleName().toString())) &#123;</span><br><span class="line">          processingEnv.getMessager().printMessage(Kind.ERROR,</span><br><span class="line">              String.format(<span class="string">&quot;getter not found for &#x27;%s.%s&#x27;.&quot;</span>, annotatedClass.getSimpleName(), field.getSimpleName()));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">containsGetter</span><span class="params">(TypeElement typeElement, String name)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">getter</span> <span class="operator">=</span> <span class="string">&quot;get&quot;</span> + name.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + name.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (ExecutableElement executableElement : ElementFilter.methodsIn(typeElement.getEnclosedElements())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!executableElement.getModifiers().contains(Modifier.STATIC)</span><br><span class="line">          &amp;&amp; executableElement.getSimpleName().toString().equals(getter)</span><br><span class="line">          &amp;&amp; executableElement.getParameters().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解处理器仅重写了process方法。这个方法将接收两个参数，分别代表该注解处理器所能处理的注解类型，以及囊括当前轮生成的抽象语法树的RoundEnvironment。</p>
<p>由于该处理器针对的注解仅有@CheckGetter一个，而且我们并不会读取注解中的值，因此第一个参数并不重要。在代码中，我直接使用了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`roundEnv.getElementsAnnotatedWith(CheckGetter.class)`</span><br></pre></td></tr></table></figure>

<p>来获取所有被@CheckGetter注解的类（以及字段）。</p>
<p>process方法涉及各种不同类型的Element，分别指代 Java 程序中的各个结构。如TypeElement指代类或者接口，VariableElement指代字段、局部变量、enum 常量等，ExecutableElement指代方法或者构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;     <span class="comment">// PackageElement</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;      <span class="comment">// TypeElement</span></span><br><span class="line">  <span class="type">int</span> a;           <span class="comment">// VariableElement</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> b;    <span class="comment">// VariableElement</span></span><br><span class="line">  Foo () &#123;&#125;        <span class="comment">// ExecutableElement</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setA</span> <span class="params">(      // ExecutableElement</span></span><br><span class="line"><span class="params">    <span class="type">int</span> newA         // VariableElement</span></span><br><span class="line"><span class="params">  )</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些结构之间也有从属关系，如上面这段代码所示 (出处 [2]）。我们可以通过TypeElement.getEnclosedElements方法，获得上面这段代码中Foo类的字段、构造器以及方法。</p>
<p>我们也可以通过ExecutableElement.getParameters方法，获得setA方法的参数。具体这些Element类都有哪些 API，你可以参考它们的 Javadoc[3]。</p>
<p>在将该注解处理器编译成 class 文件后，我们便可以将其注册为 Java 编译器的插件，并用来处理其他源代码。注册的方法主要有两种。第一种是直接使用 javac 命令的-processor参数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac -cp /CLASSPATH/TO/CheckGetterProcessor -processor bar.CheckGetterProcessor Foo.java</span><br><span class="line">error: Class <span class="string">&#x27;Foo&#x27;</span> is annotated as <span class="meta">@CheckGetter</span>, but field <span class="string">&#x27;a&#x27;</span> is without getter</span><br><span class="line"><span class="number">1</span> error</span><br></pre></td></tr></table></figure>

<p>第二种则是将注解处理器编译生成的 class 文件压缩入 jar 包中，并在 jar 包的配置文件中记录该注解处理器的包名及类名，即bar.CheckGetterProcessor。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（具体路径及配置文件名为`META-INF/services/javax.annotation.processing.Processor`）</span><br></pre></td></tr></table></figure>

<p>当启动 Java 编译器时，它会寻找 classpath 路径上的 jar 包是否包含上述配置文件，并自动注册其中记录的注解处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac -cp /PATH/TO/CheckGetterProcessor.jar Foo.java</span><br><span class="line">error: Class <span class="string">&#x27;Foo&#x27;</span> is annotated as <span class="meta">@CheckGetter</span>, but field <span class="string">&#x27;a&#x27;</span> is without getter</span><br><span class="line"><span class="number">1</span> error</span><br></pre></td></tr></table></figure>

<p>此外，我们还可以在 IDE 中配置注解处理器。这里我就不过多演示了，感兴趣的同学可以自行搜索。</p>
<h1 id="利用注解处理器生成源代码"><a href="#利用注解处理器生成源代码" class="headerlink" title="利用注解处理器生成源代码"></a>利用注解处理器生成源代码</h1><p>前面提到，注解处理器可以用来修改已有源代码或者生成源代码。</p>
<p>确切地说，注解处理器并不能真正地修改已有源代码。这里指的是修改由 Java 源代码生成的抽象语法树，在其中修改已有树节点或者插入新的树节点，从而使生成的字节码发生变化。</p>
<p>对抽象语法树的修改涉及了 Java 编译器的内部 API，这部分很可能随着版本变更而失效。因此，我并不推荐这种修改方式。</p>
<p>如果你感兴趣的话，可以参考 [Project Lombok][4]。这个项目自定义了一系列注解，并根据注解的内容来修改已有的源代码。例如它提供了@Getter和@Setter注解，能够为程序自动添加getter以及setter方法。有关对使用内部 API 的讨论，你可以参考 [这篇博客][5]，以及 [Lombok 的回应][6]。</p>
<p>用注解处理器来生成源代码则比较常用。我们以前介绍过的压力测试 jcstress，以及接下来即将介绍的 JMH 工具，都是依赖这种方式来生成测试代码的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adapt &#123;</span><br><span class="line">  Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，我定义了一个注解@Adapt。这个注解将接收一个Class类型的参数value（如果注解类仅包含一个名为value的参数时，那么在使用注解时，我们可以省略value&#x3D;），具体用法如这段代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bar.java</span></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> foo.Adapt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="meta">@Adapt(IntBinaryOperator.class)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来实现一个处理@Adapt注解的处理器。该处理器将生成一个新的源文件，实现参数value所指定的接口，并且调用至被该注解所标注的方法之中。具体的实现代码比较长，建议你在<a href="https://time.geekbang.org/column/108">网页端</a>观看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bar;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.type.TypeMirror;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementFilter;</span><br><span class="line"><span class="keyword">import</span> javax.tools.JavaFileObject;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.tools.Diagnostic.Kind;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;foo.Adapt&quot;)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="string">&quot;foo.Adapt&quot;</span>.equals(annotation.getQualifiedName().toString())) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="type">ExecutableElement</span> <span class="variable">targetAsKey</span> <span class="operator">=</span> getExecutable(annotation, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span> (ExecutableElement annotatedMethod : ElementFilter.methodsIn(roundEnv.getElementsAnnotatedWith(annotation))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!annotatedMethod.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">          processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">&quot;@Adapt on non-public method&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!annotatedMethod.getModifiers().contains(Modifier.STATIC)) &#123;</span><br><span class="line">          <span class="comment">// TODO support non-static methods</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">targetInterface</span> <span class="operator">=</span> getAnnotationValueAsTypeElement(annotatedMethod, annotation, targetAsKey);</span><br><span class="line">        <span class="keyword">if</span> (targetInterface.getKind() != ElementKind.INTERFACE) &#123;</span><br><span class="line">          processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">&quot;@Adapt with non-interface input&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">enclosingType</span> <span class="operator">=</span> getTopLevelEnclosingType(annotatedMethod);</span><br><span class="line">        createAdapter(enclosingType, annotatedMethod, targetInterface);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createAdapter</span><span class="params">(TypeElement enclosingClass, ExecutableElement annotatedMethod,</span></span><br><span class="line"><span class="params">      TypeElement targetInterface)</span> &#123;</span><br><span class="line">    <span class="type">PackageElement</span> <span class="variable">packageElement</span> <span class="operator">=</span> (PackageElement) enclosingClass.getEnclosingElement();</span><br><span class="line">    <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> enclosingClass.getSimpleName().toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> annotatedMethod.getSimpleName().toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">adapterName</span> <span class="operator">=</span> className + <span class="string">&quot;_&quot;</span> + methodName + <span class="string">&quot;Adapter&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">ExecutableElement</span> <span class="variable">overriddenMethod</span> <span class="operator">=</span> getFirstNonDefaultExecutable(targetInterface);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Filer</span> <span class="variable">filer</span> <span class="operator">=</span> processingEnv.getFiler();</span><br><span class="line">      <span class="type">JavaFileObject</span> <span class="variable">sourceFile</span> <span class="operator">=</span> filer.createSourceFile(packageName + <span class="string">&quot;.&quot;</span> + adapterName, <span class="keyword">new</span> <span class="title class_">Element</span>[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(sourceFile.openWriter())) &#123;</span><br><span class="line">        out.println(<span class="string">&quot;package &quot;</span> + packageName + <span class="string">&quot;;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;import &quot;</span> + targetInterface.getQualifiedName() + <span class="string">&quot;;&quot;</span>);</span><br><span class="line">        out.println();</span><br><span class="line">        out.println(<span class="string">&quot;public class &quot;</span> + adapterName + <span class="string">&quot; implements &quot;</span> + targetInterface.getSimpleName() + <span class="string">&quot; &#123;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;  @Override&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;  public &quot;</span> + overriddenMethod.getReturnType() + <span class="string">&quot; &quot;</span> + overriddenMethod.getSimpleName()</span><br><span class="line">            + formatParameter(overriddenMethod, <span class="literal">true</span>) + <span class="string">&quot; &#123;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;    return &quot;</span> + className + <span class="string">&quot;.&quot;</span> + methodName + formatParameter(overriddenMethod, <span class="literal">false</span>) + <span class="string">&quot;;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;  &#125;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> ExecutableElement <span class="title function_">getExecutable</span><span class="params">(TypeElement annotation, String methodName)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ExecutableElement method : ElementFilter.methodsIn(annotation.getEnclosedElements())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methodName.equals(method.getSimpleName().toString())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">&quot;Incompatible @Adapt.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> ExecutableElement <span class="title function_">getFirstNonDefaultExecutable</span><span class="params">(TypeElement annotation)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ExecutableElement method : ElementFilter.methodsIn(annotation.getEnclosedElements())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!method.isDefault()) &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processingEnv.getMessager().printMessage(Kind.ERROR,</span><br><span class="line">        <span class="string">&quot;Target interface should declare at least one non-default method.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> TypeElement <span class="title function_">getAnnotationValueAsTypeElement</span><span class="params">(ExecutableElement annotatedMethod, TypeElement annotation,</span></span><br><span class="line"><span class="params">      ExecutableElement annotationFunction)</span> &#123;</span><br><span class="line">    <span class="type">TypeMirror</span> <span class="variable">annotationType</span> <span class="operator">=</span> annotation.asType();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (AnnotationMirror annotationMirror : annotatedMethod.getAnnotationMirrors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (processingEnv.getTypeUtils().isSameType(annotationMirror.getAnnotationType(), annotationType)) &#123;</span><br><span class="line">        <span class="type">AnnotationValue</span> <span class="variable">value</span> <span class="operator">=</span> annotationMirror.getElementValues().get(annotationFunction);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">          processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">&quot;Unknown @Adapt target&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TypeMirror</span> <span class="variable">targetInterfaceTypeMirror</span> <span class="operator">=</span> (TypeMirror) value.getValue();</span><br><span class="line">        <span class="keyword">return</span> (TypeElement) processingEnv.getTypeUtils().asElement(targetInterfaceTypeMirror);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">&quot;@Adapt should contain target()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> TypeElement <span class="title function_">getTopLevelEnclosingType</span><span class="params">(ExecutableElement annotatedMethod)</span> &#123;</span><br><span class="line">    <span class="type">TypeElement</span> <span class="variable">enclosingType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Element</span> <span class="variable">enclosing</span> <span class="operator">=</span> annotatedMethod.getEnclosingElement();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (enclosing != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (enclosing.getKind() == ElementKind.CLASS) &#123;</span><br><span class="line">        enclosingType = (TypeElement) enclosing;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enclosing.getKind() == ElementKind.PACKAGE) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      enclosing = enclosing.getEnclosingElement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enclosingType;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">formatParameter</span><span class="params">(ExecutableElement method, <span class="type">boolean</span> includeType)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    builder.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">separator</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (VariableElement parameter : method.getParameters()) &#123;</span><br><span class="line">      builder.append(separator);</span><br><span class="line">      <span class="keyword">if</span> (includeType) &#123;</span><br><span class="line">        builder.append(parameter.asType());</span><br><span class="line">        builder.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      builder.append(parameter.getSimpleName());</span><br><span class="line">      separator = <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个注解处理器实现中，我们将读取注解中的值，因此我将使用process方法的第一个参数，并通过它获得被标注方法对应的@Adapt注解中的value值。</p>
<p>之所以采用这种麻烦的方式，是因为value值属于Class类型。在编译过程中，被编译代码中的Class常量未必被加载进 Java 编译器所在的虚拟机中。因此，我们需要通过process方法的第一个参数，获得value所指向的接口的抽象语法树，并据此生成源代码。</p>
<p>生成源代码的方式实际上非常容易理解。我们可以通过Filer.createSourceFile方法获得一个类似于文件的概念，并通过PrintWriter将具体的内容一一写入即可。</p>
<p>当将该注解处理器作为插件接入 Java 编译器时，编译前面的test&#x2F;Bar.java将生成下述代码，并且触发新一轮的编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntBinaryOperator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar_addAdapter</span> <span class="keyword">implements</span> <span class="title class_">IntBinaryOperator</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">applyAsInt</span><span class="params">(<span class="type">int</span> arg0, <span class="type">int</span> arg1)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Bar.add(arg0, arg1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，该注解处理器没有处理所编译的代码包名为空的情况。</p>
</blockquote>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>今天我介绍了 Java 编译器的注解处理器。</p>
<p>注解处理器主要有三个用途。一是定义编译规则，并检查被编译的源文件。二是修改已有源代码。三是生成新的源代码。其中，第二种涉及了 Java 编译器的内部 API，因此并不推荐。第三种较为常见，是 OpenJDK 工具 jcstress，以及 JMH 生成测试代码的方式。</p>
<p>Java 源代码的编译过程可分为三个步骤，分别为解析源文件生成抽象语法树，调用已注册的注解处理器，和生成字节码。如果在第 2 步中，注解处理器生成了新的源代码，那么 Java 编译器将重复第 1、2 步，直至不再生成新的源代码。</p>
<p>今天的实践环节，请实现本文的案例CheckGetterProcessor中的 TODO 项，处理由@CheckGetter注解的字段。</p>
<p>[1] <a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html">http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html</a><br>[2] <a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101">http://hannesdorfmann.com/annotation-processing/annotationprocessing101</a><br>[3] <a href="https://docs.oracle.com/javase/10/docs/api/javax/lang/model/element/package-summary.html">https://docs.oracle.com/javase/10/docs/api/javax/lang/model/element/package-summary.html</a><br>[4] <a href="https://projectlombok.org/">https://projectlombok.org/</a><br>[5] <a href="http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html">http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html</a><br>[6] <a href="http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy">http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sealin.net/2020/01/23/jvm-26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sealin">
      <meta itemprop="description" content="不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sealin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/jvm-26/" class="post-title-link" itemprop="url">26 | 向量化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 16:15:55" itemprop="dateCreated datePublished" datetime="2020-01-23T16:15:55+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-23 09:43:32" itemprop="dateModified" datetime="2023-05-23T09:43:32+08:00">2023-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">深入拆解 Java 虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        <div id="aplayer-RKMDkRrK" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-RKMDkRrK"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "音频26",
              author: "郑雨迪",
              url: "https://res001.geekbang.org/resource/audio/31/c3/31fb9a7102357bbc0a5656e0b5aa4ec3.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<p>在上一篇的实践环节中，我给你留了一个题目：如何进一步优化下面这段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">byte</span>[] src)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dst.length - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    dst[i] = src[i];</span><br><span class="line">    dst[i+<span class="number">1</span>] = src[i+<span class="number">1</span>];</span><br><span class="line">    dst[i+<span class="number">2</span>] = src[i+<span class="number">2</span>];</span><br><span class="line">    dst[i+<span class="number">3</span>] = src[i+<span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  ... <span class="comment">// post-loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 X86_64 平台不支持内存间的直接移动，上面代码中的dst[i] &#x3D; src[i]通常会被编译为两条内存访问指令：第一条指令把src[i]的值读取至寄存器中，而第二条指令则把寄存器中的值写入至dst[i]中。</p>
<p>因此，上面这段代码中的一个循环迭代将会执行四条内存读取指令，以及四条内存写入指令。</p>
<p>由于数组元素在内存中是连续的，当从src[i]的内存地址处读取 32 位的内容时，我们将一并读取src[i]至src[i+3]的值。同样，当向dst[i]的内存地址处写入 32 位的内容时，我们将一并写入dst[i]至dst[i+3]的值。</p>
<p>通过综合这两个批量操作，我们可以使用一条内存读取指令以及一条内存写入指令，完成上面代码中循环体内的全部工作。如果我们用x[i:i+3]来指代x[i]至x[i+3]合并后的值，那么上述优化可以被表述成如下所示的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">byte</span>[] src)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dst.length - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    dst[i:i+<span class="number">3</span>] = src[i:i+<span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  ... <span class="comment">// post-loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SIMD-指令"><a href="#SIMD-指令" class="headerlink" title="SIMD 指令"></a>SIMD 指令</h1><p>在前面的示例中，我们使用的是 byte 数组，四个数组元素并起来也才 4 个字节。如果换成 int 数组，或者 long 数组，那么四个数组元素并起来将会是 16 字节或 32 字节。</p>
<p>我们知道，X86_64 体系架构上通用寄存器的大小为 64 位（即 8 个字节），无法暂存这些超长的数据。因此，即时编译器将借助长度足够的 XMM 寄存器，来完成 int 数组与 long 数组的向量化读取和写入操作。（为了实现方便，byte 数组的向量化读取、写入操作同样使用了 XMM 寄存器。）</p>
<p>所谓的 XMM 寄存器，是由 SSE（Streaming SIMD Extensions）指令集所引入的。它们一开始仅为 128 位。自从 X86 平台上的 CPU 开始支持 AVX（Advanced Vector Extensions）指令集后（2011 年），XMM 寄存器便升级为 256 位，并更名为 YMM 寄存器。原本使用 XMM 寄存器的指令，现将使用 YMM 寄存器的低 128 位。</p>
<p>前几年推出的 AVX512 指令集，更是将 YMM 寄存器升级至 512 位，并更名为 ZMM 寄存器。HotSpot 虚拟机也紧跟时代，更新了不少基于 AVX512 指令集以及 ZMM 寄存器的优化。不过，支持 AVX512 指令集的 CPU 都比较贵，目前在生产环境中很少见到。</p>
<p><img src="/images/2020/01/23/bacb0c00-3db7-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>SSE 指令集以及之后的 AVX 指令集都涉及了一个重要的概念，那便是单指令流多数据流（Single Instruction Multiple Data，SIMD），即通过单条指令操控多组数据的计算操作。这些指令我们称之为 SIMD 指令。</p>
<p>SIMD 指令将 XMM 寄存器（或 YMM 寄存器、ZMM 寄存器）中的值看成多个整数或者浮点数组成的向量，并且批量进行计算。</p>
<p><img src="/images/2020/01/23/c83ecd90-3db7-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>举例来说，128 位 XMM 寄存器里的值可以看成 16 个 byte 值组成的向量，或者 8 个 short 值组成的向量，4 个 int 值组成的向量，两个 long 值组成的向量；而 SIMD 指令PADDB、PADDW、PADDD以及PADDQ，将分别实现 byte 值、short 值、int 值或者 long 值的向量加法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b, <span class="type">int</span>[] c)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码经过向量化优化之后，将使用PADDD指令来实现c[i:i+3] &#x3D; a[i:i+3] + b[i:i+3]。其执行过程中的数据流如下图所示，图片源自 Vladimir Ivanov 的演讲 [1]。下图中内存的右边是高位，寄存器的左边是高位，因此数组元素的顺序是反过来的。</p>
<p><img src="/images/2020/01/23/d4ae8ca0-3db7-11ea-87eb-3d1d349c50f2.png" alt="image.png"></p>
<p>也就是说，原本需要c.length次加法操作的代码，现在最少只需要c.length&#x2F;4次向量加法即可完成。因此，SIMD 指令也被看成 CPU 指令级别的并行。</p>
<blockquote>
<p>这里c.length&#x2F;4次是理论值。现实中，C2 还将考虑缓存行对齐等因素，导致能够应用向量化加法的仅有数组中间的部分元素。</p>
</blockquote>
<h1 id="使用-SIMD-指令的-HotSpot-Intrinsic"><a href="#使用-SIMD-指令的-HotSpot-Intrinsic" class="headerlink" title="使用 SIMD 指令的 HotSpot Intrinsic"></a>使用 SIMD 指令的 HotSpot Intrinsic</h1><p>SIMD 指令虽然非常高效，但是使用起来却很麻烦。这主要是因为不同的 CPU 所支持的 SIMD 指令可能不同。一般来说，越新的 SIMD 指令，它所支持的寄存器长度越大，功能也越强。</p>
<blockquote>
<p>目前几乎所有的 X86_64 平台上的 CPU 都支持 SSE 指令集，绝大部分支持 AVX 指令集，三四年前量产的 CPU 支持 AVX2 指令集，最近少数服务器端 CPU 支持 AVX512 指令集。AVX512 指令集的提升巨大，因为它不仅将寄存器长度增大至 512 字节，而且引入了非常多的新指令。</p>
</blockquote>
<p>为了能够尽量利用新的 SIMD 指令，我们需要提前知道程序会被运行在支持哪些指令集的 CPU 上，并在编译过程中选择所支持的 SIMD 指令中最新的那些。</p>
<p>或者，我们可以在编译结果中纳入同一段代码的不同版本，每个版本使用不同的 SIMD 指令。在运行过程中，程序将根据 CPU 所支持的指令集，来选择执行哪一个版本。</p>
<blockquote>
<p>虽然程序中包含当前 CPU 可能不支持的指令，但是只要不执行到这些指令，程序便不会出问题。如果不小心执行到这些不支持的指令，CPU 会触发一个中断，并向当前进程发出sigill信号。</p>
</blockquote>
<p>不过，这对于使用即时编译技术的 Java 虚拟机来说，并不是一个大问题。</p>
<p>我们知道，Java 虚拟机所执行的 Java 字节码是平台无关的。它首先会被解释执行，而后反复执行的部分才会被 Java 虚拟机即时编译为机器码。换句话说，在进行即时编译的时候，Java 虚拟机已经运行在目标 CPU 之上，可以轻易地得知其所支持的指令集。</p>
<p>然而，Java 字节码的平台无关性却引发了另一个问题，那便是 Java 程序无法像 C++ 程序那样，直接使用由 Intel 提供的，将被替换为具体 SIMD 指令的 intrinsic 方法 [2]。</p>
<p>HotSpot 虚拟机提供的替代方案是 Java 层面的 intrinsic 方法，这些 intrinsic 方法的语义要比单个 SIMD 指令复杂得多。在运行过程中，HotSpot 虚拟机将根据当前体系架构来决定是否将对该 intrinsic 方法的调用替换为另一高效的实现。如果不，则使用原本的 Java 实现。</p>
<p>举个例子，Java 8 中Arrays.equals(int[], int[])的实现将逐个比较 int 数组中的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] a2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a==a2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="literal">null</span> || a2==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">if</span> (a2.length != length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 关键循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != a2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 intrinsic 高效实现会将数组的多个元素加载至 XMM&#x2F;YMM&#x2F;ZMM 寄存器中，然后进行按位比较。如果两个数组相同，那么其中若干个元素合并而成的值也相同，其按位比较也应成功。反过来，如果按位比较失败，则说明两个数组不同。</p>
<p>使用 SIMD 指令的 HotSpot intrinsic 是虚拟机开发人员根据其语义定制的，因而性能相当优越。</p>
<p>不过，由于开发成本及维护成本较高，这种类型的 intrinsic 屈指可数，如用于复制数组的System.arraycopy和Arrays.copyOf，用于比较数组的Arrays.equals，以及 Java 9 新加入的Arrays.compare和Arrays.mismatch，以及字符串相关的一些方法String.indexOf、StringLatin1.inflate。</p>
<blockquote>
<p>Arrays.copyOf将调用System.arraycopy，实际上只有后者是 intrinsic。在 Java 9 之后，数组比较真正的 intrinsic 是ArraySupports.vectorizedMismatch方法，而Arrays.equals、Arrays.compare和Arrays.mismatch将调用至该方法中。</p>
</blockquote>
<p>另外，这些 intrinsic 方法只能做到点覆盖，在不少情况下，应用程序并不会用到这些 intrinsic 的语义，却又存在向量化优化的机会。这个时候，我们便需要借助即时编译器中的自动向量化（auto vectorization）。</p>
<h1 id="自动向量化"><a href="#自动向量化" class="headerlink" title="自动向量化"></a>自动向量化</h1><p>即时编译器的自动向量化将针对能够展开的计数循环，进行向量化优化。如前面介绍过的这段代码，即时编译器便能够自动将其展开优化成使用PADDD指令的向量加法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b, <span class="type">int</span>[] c)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于计数循环的判定，我在上一篇介绍循环优化时已经讲解过了，这里我补充几点自动向量化的条件。</p>
<ol>
<li>循环变量的增量应为 1，即能够遍历整个数组。</li>
<li>循环变量不能为 long 类型，否则 C2 无法将循环识别为计数循环。</li>
<li>循环迭代之间最好不要有数据依赖，例如出现类似于a[i] &#x3D; a[i-1]的语句。当循环展开之后，循环体内存在数据依赖，那么 C2 无法进行自动向量化。</li>
<li>循环体内不要有分支跳转。</li>
<li>不要手工进行循环展开。如果 C2 无法自动展开，那么它也将无法进行自动向量化。</li>
</ol>
<p>我们可以看到，自动向量化的条件较为苛刻。而且，C2 支持的整数向量化操作并不多，据我所致只有向量加法，向量减法，按位与、或、异或，以及批量移位和批量乘法。C2 还支持向量点积的自动向量化，即两两相乘再求和，不过这需要多条 SIMD 指令才能完成，因此并不是十分高效。</p>
<p>为了解决向量化 intrinsic 以及自动向量化覆盖面过窄的问题，我们在 OpenJDK 的 Paname 项目 [3] 中尝试引入开发人员可控的向量化抽象。</p>
<p>该抽象将提供一套通用的跨平台 API，让 Java 程序能够定义诸如IntVector<S256Bits>的向量，并使用由它提供的一系列向量化 intrinsic 方法。即时编译器负责将这些 intrinsic 的调用转换为符合当前体系架构 &#x2F;CPU 的 SIMD 指令。如果你感兴趣的话，可以参考 Vladimir Ivanov 今年在 JVMLS 上的演讲 [4]。</p>
<h1 id="总结与实践"><a href="#总结与实践" class="headerlink" title="总结与实践"></a>总结与实践</h1><p>今天我介绍了即时编译器中的向量化优化。</p>
<p>向量化优化借助的是 CPU 的 SIMD 指令，即通过单条指令控制多组数据的运算。它被称为 CPU 指令级别的并行。</p>
<p>HotSpot 虚拟机运用向量化优化的方式有两种。第一种是使用 HotSpot intrinsic，在调用特定方法的时候替换为使用了 SIMD 指令的高效实现。Intrinsic 属于点覆盖，只有当应用程序明确需要这些 intrinsic 的语义，才能够获得由它带来的性能提升。</p>
<p>第二种是依赖即时编译器进行自动向量化，在循环展开优化之后将不同迭代的运算合并为向量运算。自动向量化的触发条件较为苛刻，因此也无法覆盖大多数用例。</p>
<p>今天的实践环节，我们来观察一下即时编译器的自动向量化的自适配性。</p>
<p>在支持 256 位 YMM 寄存器的机器上，C2 会根据循环回边的执行次数以及方法的执行次数来推测每个循环的次数。如果超过一定值，C2 会采用基于 256 位 YMM 寄存器的指令，相比起基于 128 位 XMM 寄存器的指令而言，单指令能处理的数据翻了一倍。</p>
<p>请采用 Java 9 以上的版本运行下述代码。（Java 8 始终采用基于 128 位 XMM 寄存器指令的 Bug 可能仍未修复。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run with </span></span><br><span class="line"><span class="comment">// java -XX:CompileCommand=&#x27;dontinline VectorizationTest.foo&#x27; -XX:CompileCommand=&#x27;print VectorizationTest.foo&#x27; -XX:-TieredCompilation VectorizationTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorizationTest</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b, <span class="type">int</span>[] c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">      c[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20_000</span>; i++) &#123;</span><br><span class="line">      foo(a, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出将包含如下机器码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x000000011ce7c650</span>: vmovdqu xmm0,XMMWORD PTR [rdx+rbx*<span class="number">4</span>+<span class="number">0x10</span>]</span><br><span class="line"><span class="number">0x000000011ce7c656</span>: vpaddd xmm0,xmm0,XMMWORD PTR [rsi+rbx*<span class="number">4</span>+<span class="number">0x10</span>]</span><br><span class="line"><span class="number">0x000000011ce7c65c</span>: vmovdqu XMMWORD PTR [rcx+rbx*<span class="number">4</span>+<span class="number">0x10</span>],xmm0</span><br></pre></td></tr></table></figure>

<p>如果替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br></pre></td></tr></table></figure>

<p>输出将包含如下机器码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x000000010ff04d9c</span>: vmovdqu ymm0,YMMWORD PTR [rdx+rbx*<span class="number">4</span>+<span class="number">0x10</span>]</span><br><span class="line"><span class="number">0x000000010ff04da2</span>: vpaddd ymm0,ymm0,YMMWORD PTR [rsi+rbx*<span class="number">4</span>+<span class="number">0x10</span>]</span><br><span class="line"><span class="number">0x000000010ff04da8</span>: vmovdqu YMMWORD PTR [rcx+rbx*<span class="number">4</span>+<span class="number">0x10</span>],ymm0</span><br></pre></td></tr></table></figure>

<p>你可以将foo方法更改为下述代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    a[i] = a[i - <span class="number">4</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复上述实验，看看会发生什么。</p>
<p>[1] <a href="http://cr.openjdk.java.net/~vlivanov/talks/2017_Vectorization_in_HotSpot_JVM.pdf">http://cr.openjdk.java.net/~vlivanov/talks/2017_Vectorization_in_HotSpot_JVM.pdf</a><br>[2] <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">https://software.intel.com/sites/landingpage/IntrinsicsGuide/</a><br>[3] <a href="http://openjdk.java.net/projects/panama/">http://openjdk.java.net/projects/panama/</a><br>[4]: <a href="http://cr.openjdk.java.net/~vlivanov/talks/2018_JVMLS_VectorAPI.pdf">http://cr.openjdk.java.net/~vlivanov/talks/2018_JVMLS_VectorAPI.pdf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sealin"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Sealin</p>
  <div class="site-description" itemprop="description">不妄取, 不妄予, 不妄想, 不妄求;<br>与人方便, 随遇而安。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sealin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  


</body>
</html>
